.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::Compile 3pm"
.TH CGI::Compile 3pm "2016-01-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Compile \- Compile .cgi scripts to a code reference like ModPerl::Registry
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use CGI::Compile;
\&  my $sub = CGI::Compile\->compile("/path/to/script.cgi");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
CGI::Compile is a utility to compile \s-1CGI\s0 scripts into a code
reference that can run many times on its own namespace, as long as the
script is ready to run on a persistent environment.
.PP
\&\fB\s-1NOTE:\s0\fR for best results, load CGI::Compile before any modules used by your
CGIs.
.SH "RUN ON PSGI"
.IX Header "RUN ON PSGI"
Combined with CGI::Emulate::PSGI, your \s-1CGI\s0 script can be turned
into a persistent \s-1PSGI\s0 application like:
.PP
.Vb 2
\&  use CGI::Emulate::PSGI;
\&  use CGI::Compile;
\&
\&  my $cgi_script = "/path/to/foo.cgi";
\&  my $sub = CGI::Compile\->compile($cgi_script);
\&  my $app = CGI::Emulate::PSGI\->handler($sub);
\&
\&  # $app is a PSGI application
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
If your \s-1CGI\s0 script has a subroutine that references the lexical scope
variable outside the subroutine, you'll see warnings such as:
.PP
.Vb 2
\&  Variable "$q" is not available at ...
\&  Variable "$counter" will not stay shared at ...
.Ve
.PP
This is due to the way this module compiles the whole script into a
big \f(CW\*(C`sub\*(C'\fR. To solve this, you have to update your code to pass around
the lexical variables, or replace \f(CW\*(C`my\*(C'\fR with \f(CW\*(C`our\*(C'\fR. See also
<http://perl.apache.org/docs/1.0/guide/porting.html#The_First_Mystery>
for more details.
.SH "METHODS"
.IX Header "METHODS"
.SS "new"
.IX Subsection "new"
Does not need to be called, you only need to call it if you want to set your
own \f(CW\*(C`namespace_root\*(C'\fR for the generated packages into which the CGIs are
compiled into.
.PP
Otherwise you can just call \*(L"compile\*(R" as a class method and the object will
be instantiated with a \f(CW\*(C`namespace_root\*(C'\fR of \f(CW\*(C`CGI::Compile::ROOT\*(C'\fR.
.PP
You can also set \f(CW\*(C`return_exit_val\*(C'\fR, see \*(L"\s-1RETURN CODE\*(R"\s0 for details.
.PP
Example:
.PP
.Vb 2
\&    my $compiler = CGI::Compile\->new(namespace_root => \*(AqMy::CGIs\*(Aq);
\&    my $cgi      = $compiler\->compile(\*(Aq/var/www/cgi\-bin/my.cgi\*(Aq);
.Ve
.SS "compile"
.IX Subsection "compile"
Takes either a path to a perl \s-1CGI\s0 script or a source code and some
other optional parameters and wraps it into a coderef for execution.
.PP
Can be called as either a class or instance method, see \*(L"new\*(R" above.
.PP
Parameters:
.IP "\(bu" 4
\&\f(CW$cgi_script\fR
.Sp
Path to perl \s-1CGI\s0 script file or a scalar reference that contains the
source code of \s-1CGI\s0 script, required.
.IP "\(bu" 4
\&\f(CW$package\fR
.Sp
Optional, package to install the script into, defaults to the path parts of the
script joined with \f(CW\*(C`_\*(C'\fR, and all special characters converted to \f(CW\*(C`_%2x\*(C'\fR,
prepended with \f(CW\*(C`CGI::Compile::ROOT::\*(C'\fR.
.Sp
E.g.:
.Sp
.Vb 1
\&    /var/www/cgi\-bin/foo.cgi
.Ve
.Sp
becomes:
.Sp
.Vb 1
\&    CGI::Compile::ROOT::var_www_cgi_2dbin_foo_2ecgi
.Ve
.PP
Returns:
.IP "\(bu" 4
\&\f(CW$coderef\fR
.Sp
\&\f(CW$cgi_script\fR or \f(CW$$code\fR compiled to coderef.
.SH "SCRIPT ENVIRONMENT"
.IX Header "SCRIPT ENVIRONMENT"
.SS "\s-1ARGUMENTS\s0"
.IX Subsection "ARGUMENTS"
Things like the query string and form data should generally be in the
appropriate environment variables that things like \s-1CGI\s0 expect.
.PP
You can also pass arguments to the generated coderef, they will be
locally aliased to \f(CW@_\fR and \f(CW@ARGV\fR.
.ie n .SS """BEGIN"" and ""END"" blocks"
.el .SS "\f(CWBEGIN\fP and \f(CWEND\fP blocks"
.IX Subsection "BEGIN and END blocks"
\&\f(CW\*(C`BEGIN\*(C'\fR blocks are called once when the script is compiled.
\&\f(CW\*(C`END\*(C'\fR blocks are called when the Perl interpreter is unloaded.
.PP
This may cause surprising effects. Suppose, for instance, a script that runs
in a forking web server and is loaded in the parent process. \f(CW\*(C`END\*(C'\fR
blocks will be called once for each worker process and another time
for the parent process while \f(CW\*(C`BEGIN\*(C'\fR blocks are called only by the
parent process.
.ie n .SS "%SIG"
.el .SS "\f(CW%SIG\fP"
.IX Subsection "%SIG"
The \f(CW%SIG\fR hash is preserved meaning the script can change signal
handlers at will. The next invocation gets a pristine \f(CW%SIG\fR again.
.ie n .SS """exit"" and exceptions"
.el .SS "\f(CWexit\fP and exceptions"
.IX Subsection "exit and exceptions"
Calls to \f(CW\*(C`exit\*(C'\fR are intercepted and converted into exceptions. When
the script calls \f(CW\*(C`exit 19\*(C'\fR and exception is thrown and \f(CW$@\fR contains
a reference pointing to the array
.PP
.Vb 1
\&    ["EXIT\en", 19]
.Ve
.PP
Naturally, \*(L"$^S\*(R" in perlvar (exceptions being caught) is always \f(CW\*(C`true\*(C'\fR
during script runtime.
.PP
If you really want to exit the process call \f(CW\*(C`CORE::exit\*(C'\fR or set
\&\f(CW$CGI::Compile::USE_REAL_EXIT\fR to true before calling exit:
.PP
.Vb 2
\&    $CGI::Compile::USE_REAL_EXIT = 1;
\&    exit 19;
.Ve
.PP
Other exceptions are propagated out of the generated coderef. The coderef's
caller is responsible to catch them or the process will exit.
.SS "Return Code"
.IX Subsection "Return Code"
The generated coderef's exit value is either the parameter that was
passed to \f(CW\*(C`exit\*(C'\fR or the value of the last statement of the script. The
return code is converted into an integer.
.PP
On a \f(CW0\fR exit, the coderef will return \f(CW0\fR.
.PP
On an explicit non-zero exit, by default an exception will be thrown of
the form:
.PP
.Vb 1
\&    exited nonzero: <n>
.Ve
.PP
where \f(CW\*(C`n\*(C'\fR is the exit value.
.PP
This only happens for an actual call to \*(L"exit\*(R" in perfunc, not if the last
statement value is non-zero, which will just be returned from the
coderef.
.PP
If you would prefer that explicit non-zero exit values are returned,
rather than thrown, pass:
.PP
.Vb 1
\&    return_exit_val => 1
.Ve
.PP
in your call to \*(L"new\*(R".
.PP
Alternately, you can change this behavior globally by setting:
.PP
.Vb 1
\&    $CGI::Compile::RETURN_EXIT_VAL = 1;
.Ve
.SS "Current Working Directory"
.IX Subsection "Current Working Directory"
If \f(CW\*(C`CGI::Compile\->compile\*(C'\fR was passed a script file, the script's
directory becomes the current working directory during the runtime of
the script.
.PP
\&\s-1NOTE:\s0 to be able to switch back to the original directory, the compiled
coderef must establish the current working directory. This operation may
cause an additional flush operation on file handles.
.ie n .SS """STDIN"" and ""STDOUT"""
.el .SS "\f(CWSTDIN\fP and \f(CWSTDOUT\fP"
.IX Subsection "STDIN and STDOUT"
These file handles are not touched by \f(CW\*(C`CGI::Compile\*(C'\fR.
.ie n .SS "The ""DATA"" file handle"
.el .SS "The \f(CWDATA\fP file handle"
.IX Subsection "The DATA file handle"
If the script reads from the \f(CW\*(C`DATA\*(C'\fR file handle, it reads the \f(CW\*(C`_\|_DATA_\|_\*(C'\fR
section provided by the script just as a normal script would do. Note,
however, that the file handle is a memory handle. So, \f(CW\*(C`fileno DATA\*(C'\fR will
return \f(CW\*(C`\-1\*(C'\fR.
.SS "\s-1CGI\s0.pm integration"
.IX Subsection "CGI.pm integration"
If the subroutine \f(CW\*(C`CGI::initialize_globals\*(C'\fR is defined at script runtime,
it is called first thing by the compiled coderef.
.SH "PROTECTED METHODS"
.IX Header "PROTECTED METHODS"
These methods define some of the internal functionality of
CGI::Compile and may be overloaded if you need to subclass this
module.
.SS "_read_source"
.IX Subsection "_read_source"
Reads the source of a \s-1CGI\s0 script.
.PP
Parameters:
.IP "\(bu" 4
\&\f(CW$file_path\fR
.Sp
Path to the file the contents of which is to be read.
.PP
Returns:
.IP "\(bu" 4
\&\f(CW$source\fR
.Sp
The contents of the file as a scalar string.
.SS "_build_package"
.IX Subsection "_build_package"
Creates a package name into which the \s-1CGI\s0 coderef will be compiled into,
prepended with \f(CW\*(C`$self\-\*(C'\fR{namespace_root}>.
.PP
Parameters:
.IP "\(bu" 4
\&\f(CW$file_path\fR
.Sp
The path to the \s-1CGI\s0 script file, the package name is generated based on
this path.
.PP
Returns:
.IP "\(bu" 4
\&\f(CW$package\fR
.Sp
The generated package name.
.SS "_eval"
.IX Subsection "_eval"
Takes the generated perl code, which is the contents of the \s-1CGI\s0 script
and some other things we add to make everything work smoother, and
returns the evaluated coderef.
.PP
Currently this is done by writing out the code to a temp file and
reading it in with \*(L"do\*(R" in perlfunc so that there are no issues with
lexical context or source filters.
.PP
Parameters:
.IP "\(bu" 4
\&\f(CW$code\fR
.Sp
The generated code that will make the coderef for the \s-1CGI.\s0
.PP
Returns:
.IP "\(bu" 4
\&\f(CW$coderef\fR
.Sp
The coderef that is the resulting of evaluating the generated perl code.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tatsuhiko Miyagawa <miyagawa@bulknews.net>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
Rafael Kitover <rkitover@cpan.org>
.PP
Hans Dieter Pearcey <hdp@cpan.org>
.PP
kocoureasy <igor.bujna@post.cz>
.PP
Torsten Fo\*:rtsch <torsten.foertsch@gmx.net>
.SH "COPYRIGHT & LICENSE"
.IX Header "COPYRIGHT & LICENSE"
Copyright (c) 2009 Tatsuhiko Miyagawa <miyagawa@bulknews.net>
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ModPerl::RegistryCooker CGI::Emulate::PSGI
