.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::FastCGI::Constant 3"
.TH Net::FastCGI::Constant 3 "2010-04-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::FastCGI::Constant \- FastCGI protocol constants.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
FastCGI protocol constants.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
Constants can either be imported individually or in sets grouped by tag names. 
The tag names are:
.ie n .SS """:common"""
.el .SS "\f(CW:common\fP"
.IX Subsection ":common"
.ie n .IP """FCGI_MAX_CONTENT_LEN""" 4
.el .IP "\f(CWFCGI_MAX_CONTENT_LEN\fR" 4
.IX Item "FCGI_MAX_CONTENT_LEN"
Maximum number of octets that the content component of the record can hold. (\f(CW65535\fR)
.ie n .IP """FCGI_HEADER_LEN""" 4
.el .IP "\f(CWFCGI_HEADER_LEN\fR" 4
.IX Item "FCGI_HEADER_LEN"
Number of octets in \f(CW\*(C`FCGI_Header\*(C'\fR. (\f(CW8\fR)
.ie n .IP """FCGI_VERSION_1""" 4
.el .IP "\f(CWFCGI_VERSION_1\fR" 4
.IX Item "FCGI_VERSION_1"
Value for \f(CW\*(C`version\*(C'\fR component of \f(CW\*(C`FCGI_Header\*(C'\fR. (\f(CW1\fR)
.ie n .IP """FCGI_NULL_REQUEST_ID""" 4
.el .IP "\f(CWFCGI_NULL_REQUEST_ID\fR" 4
.IX Item "FCGI_NULL_REQUEST_ID"
Value for \f(CW\*(C`request_id\*(C'\fR component of \f(CW\*(C`FCGI_Header\*(C'\fR. (\f(CW0\fR)
.ie n .SS """:type"""
.el .SS "\f(CW:type\fP"
.IX Subsection ":type"
Values for \f(CW\*(C`type\*(C'\fR component of \f(CW\*(C`FCGI_Header\*(C'\fR.
.ie n .IP """FCGI_BEGIN_REQUEST""" 4
.el .IP "\f(CWFCGI_BEGIN_REQUEST\fR" 4
.IX Item "FCGI_BEGIN_REQUEST"
.PD 0
.ie n .IP """FCGI_ABORT_REQUEST""" 4
.el .IP "\f(CWFCGI_ABORT_REQUEST\fR" 4
.IX Item "FCGI_ABORT_REQUEST"
.ie n .IP """FCGI_END_REQUEST""" 4
.el .IP "\f(CWFCGI_END_REQUEST\fR" 4
.IX Item "FCGI_END_REQUEST"
.ie n .IP """FCGI_PARAMS""" 4
.el .IP "\f(CWFCGI_PARAMS\fR" 4
.IX Item "FCGI_PARAMS"
.ie n .IP """FCGI_STDIN""" 4
.el .IP "\f(CWFCGI_STDIN\fR" 4
.IX Item "FCGI_STDIN"
.ie n .IP """FCGI_STDOUT""" 4
.el .IP "\f(CWFCGI_STDOUT\fR" 4
.IX Item "FCGI_STDOUT"
.ie n .IP """FCGI_STDERR""" 4
.el .IP "\f(CWFCGI_STDERR\fR" 4
.IX Item "FCGI_STDERR"
.ie n .IP """FCGI_DATA""" 4
.el .IP "\f(CWFCGI_DATA\fR" 4
.IX Item "FCGI_DATA"
.ie n .IP """FCGI_GET_VALUES""" 4
.el .IP "\f(CWFCGI_GET_VALUES\fR" 4
.IX Item "FCGI_GET_VALUES"
.ie n .IP """FCGI_GET_VALUES_RESULT""" 4
.el .IP "\f(CWFCGI_GET_VALUES_RESULT\fR" 4
.IX Item "FCGI_GET_VALUES_RESULT"
.ie n .IP """FCGI_UNKNOWN_TYPE""" 4
.el .IP "\f(CWFCGI_UNKNOWN_TYPE\fR" 4
.IX Item "FCGI_UNKNOWN_TYPE"
.ie n .IP """FCGI_MAXTYPE""" 4
.el .IP "\f(CWFCGI_MAXTYPE\fR" 4
.IX Item "FCGI_MAXTYPE"
.PD
.ie n .SS """:flag"""
.el .SS "\f(CW:flag\fP"
.IX Subsection ":flag"
Mask for \f(CW\*(C`flags\*(C'\fR component of \f(CW\*(C`FCGI_BeginRequestBody\*(C'\fR.
.ie n .IP """FCGI_KEEP_CONN""" 4
.el .IP "\f(CWFCGI_KEEP_CONN\fR" 4
.IX Item "FCGI_KEEP_CONN"
.ie n .SS """:role"""
.el .SS "\f(CW:role\fP"
.IX Subsection ":role"
Values for \f(CW\*(C`role\*(C'\fR component of \f(CW\*(C`FCGI_BeginRequestBody\*(C'\fR.
.ie n .IP """FCGI_RESPONDER""" 4
.el .IP "\f(CWFCGI_RESPONDER\fR" 4
.IX Item "FCGI_RESPONDER"
.PD 0
.ie n .IP """FCGI_AUTHORIZER""" 4
.el .IP "\f(CWFCGI_AUTHORIZER\fR" 4
.IX Item "FCGI_AUTHORIZER"
.ie n .IP """FCGI_FILTER""" 4
.el .IP "\f(CWFCGI_FILTER\fR" 4
.IX Item "FCGI_FILTER"
.PD
.ie n .SS """:protocol_status"""
.el .SS "\f(CW:protocol_status\fP"
.IX Subsection ":protocol_status"
Values for \f(CW\*(C`protocol_status\*(C'\fR component of \f(CW\*(C`FCGI_EndRequestBody\*(C'\fR.
.ie n .IP """FCGI_REQUEST_COMPLETE""" 4
.el .IP "\f(CWFCGI_REQUEST_COMPLETE\fR" 4
.IX Item "FCGI_REQUEST_COMPLETE"
.PD 0
.ie n .IP """FCGI_CANT_MPX_CONN""" 4
.el .IP "\f(CWFCGI_CANT_MPX_CONN\fR" 4
.IX Item "FCGI_CANT_MPX_CONN"
.ie n .IP """FCGI_OVERLOADED""" 4
.el .IP "\f(CWFCGI_OVERLOADED\fR" 4
.IX Item "FCGI_OVERLOADED"
.ie n .IP """FCGI_UNKNOWN_ROLE""" 4
.el .IP "\f(CWFCGI_UNKNOWN_ROLE\fR" 4
.IX Item "FCGI_UNKNOWN_ROLE"
.PD
.ie n .SS """:value"""
.el .SS "\f(CW:value\fP"
.IX Subsection ":value"
Variable names for \f(CW\*(C`FCGI_GET_VALUES\*(C'\fR / \f(CW\*(C`FCGI_GET_VALUES_RESULT\*(C'\fR records.
.ie n .IP """FCGI_MAX_CONNS""" 4
.el .IP "\f(CWFCGI_MAX_CONNS\fR" 4
.IX Item "FCGI_MAX_CONNS"
.PD 0
.ie n .IP """FCGI_MAX_REQS""" 4
.el .IP "\f(CWFCGI_MAX_REQS\fR" 4
.IX Item "FCGI_MAX_REQS"
.ie n .IP """FCGI_MPXS_CONNS""" 4
.el .IP "\f(CWFCGI_MPXS_CONNS\fR" 4
.IX Item "FCGI_MPXS_CONNS"
.PD
.ie n .SS """:pack"""
.el .SS "\f(CW:pack\fP"
.IX Subsection ":pack"
\&\f(CW\*(C`pack()\*(C'\fR / \f(CW\*(C`unpack()\*(C'\fR templates
.ie n .IP """FCGI_Header""" 4
.el .IP "\f(CWFCGI_Header\fR" 4
.IX Item "FCGI_Header"
.Vb 10
\&    Octet/      0        |        1        |
\&        /                |                 |
\&       | 0 1 2 3 4 5 6 7 | 0 1 2 3 4 5 6 7 |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     0 |     Version     |      Type       |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     2 |             Request ID            |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     4 |          Content Length           |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     6 | Padding Length  |    Reserved     |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&       Total 8 octets
\&
\&    Template: CCnnCx
\&
\&    my ($version, $type, $request_id, $content_length, $padding_length)
\&      = unpack(FCGI_Header, $octets);
.Ve
.ie n .IP """FCGI_BeginRequestBody""" 4
.el .IP "\f(CWFCGI_BeginRequestBody\fR" 4
.IX Item "FCGI_BeginRequestBody"
.Vb 10
\&    Octet/      0        |        1        |
\&        /                |                 |
\&       | 0 1 2 3 4 5 6 7 | 0 1 2 3 4 5 6 7 |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     0 |                Role               |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     2 |      Flags      |                 |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+                 +
\&     4 |                                   |
\&       +              Reserved             +
\&     6 |                                   |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&       Total 8 octets
\&
\&    Template: nCx5
\&
\&    my ($role, $flags) = unpack(FCGI_BeginRequestBody, $octets);
.Ve
.ie n .IP """FCGI_EndRequestBody""" 4
.el .IP "\f(CWFCGI_EndRequestBody\fR" 4
.IX Item "FCGI_EndRequestBody"
.Vb 10
\&    Octet/      0        |        1        |
\&        /                |                 |
\&       | 0 1 2 3 4 5 6 7 | 0 1 2 3 4 5 6 7 |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     0 |                                   |
\&       +        Application Status         +
\&     2 |                                   |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     4 | Protocol Status |                 |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+    Reserved     +
\&     6 |                                   |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&       Total 8 octets
\&
\&    Template: NCx3
\&
\&    my ($app_status, $protocol_status) 
\&      = unpack(FCGI_EndRequestBody, $octets);
.Ve
.ie n .IP """FCGI_UnknownTypeBody""" 4
.el .IP "\f(CWFCGI_UnknownTypeBody\fR" 4
.IX Item "FCGI_UnknownTypeBody"
.Vb 10
\&    Octet/      0        |        1        |
\&        /                |                 |
\&       | 0 1 2 3 4 5 6 7 | 0 1 2 3 4 5 6 7 |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&     0 |  Unknown Type   |                 |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+                 +
\&     2 |                                   |
\&       +                                   +
\&     4 |              Reserved             |
\&       +                                   +
\&     6 |                                   |
\&       +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&       Total 8 octets
\&
\&    Template: Cx7
\&
\&    my $unknown_type = unpack(FCGI_UnknownTypeBody, $octets);
.Ve
.ie n .SS """:name"""
.el .SS "\f(CW:name\fP"
.IX Subsection ":name"
Arrays containing names of value components. These are read-only.
.ie n .IP "@FCGI_TYPE_NAME" 4
.el .IP "\f(CW@FCGI_TYPE_NAME\fR" 4
.IX Item "@FCGI_TYPE_NAME"
.Vb 1
\&    print $FCGI_TYPE_NAME[FCGI_BEGIN_REQUEST]; # FCGI_BEGIN_REQUEST
.Ve
.ie n .IP "@FCGI_ROLE_NAME" 4
.el .IP "\f(CW@FCGI_ROLE_NAME\fR" 4
.IX Item "@FCGI_ROLE_NAME"
.Vb 1
\&    print $FCGI_ROLE_NAME[FCGI_RESPONDER]; # FCGI_RESPONDER
.Ve
.ie n .IP "@FCGI_PROTOCOL_STATUS_NAME" 4
.el .IP "\f(CW@FCGI_PROTOCOL_STATUS_NAME\fR" 4
.IX Item "@FCGI_PROTOCOL_STATUS_NAME"
.Vb 1
\&    print $FCGI_PROTOCOL_STATUS_NAME[FCGI_OVERLOADED]; # FCGI_OVERLOADED
.Ve
.PP
\&\fINote\fR
.PP
It's not safe to assume that \f(CW\*(C`exists\*(C'\fR works for validation purposes, index \f(CW0\fR 
might be \f(CW\*(C`undef\*(C'\fR.
.PP
Use boolean context instead:
.PP
.Vb 2
\&    ($FCGI_TYPE_NAME[$type])
\&      || die;
.Ve
.SH "EXPORTS"
.IX Header "EXPORTS"
None by default. All functions can be exported using the \f(CW\*(C`:all\*(C'\fR tag or individually.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "<http://www.fastcgi.com/devkit/doc/fcgi\-spec.html>" 4
.IX Item "<http://www.fastcgi.com/devkit/doc/fcgi-spec.html>"
.SH "AUTHOR"
.IX Header "AUTHOR"
Christian Hansen \f(CW\*(C`chansen@cpan.org\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2008\-2010 by Christian Hansen.
.PP
This library is free software; you can redistribute it and/or modify 
it under the same terms as Perl itself.
