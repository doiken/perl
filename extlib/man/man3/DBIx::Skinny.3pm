.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Skinny 3"
.TH DBIx::Skinny 3 "2011-09-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Skinny \- simple DBI wrapper/ORMapper
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
create your db model base class.
.PP
.Vb 7
\&    package Your::Model;
\&    use DBIx::Skinny connect_info => {
\&        dsn => \*(Aqdbi:SQLite:\*(Aq,
\&        username => \*(Aq\*(Aq,
\&        password => \*(Aq\*(Aq,
\&    };
\&    1;
.Ve
.PP
create your db schema class.
See DBIx::Skinny::Schema for docs on defining schema class.
.PP
.Vb 2
\&    package Your::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    
\&    install_table user => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id
\&            name
\&        /;
\&    };
\&    1;
.Ve
.PP
in your script.
.PP
.Vb 1
\&    use Your::Model;
\&    
\&    my $skinny = Your::Model\->new;
\&    # insert new record.
\&    my $row = $skinny\->insert(\*(Aquser\*(Aq,
\&        {
\&            id   => 1,
\&        }
\&    );
\&    $row\->update({name => \*(Aqnekokak\*(Aq});
\&
\&    $row = $skinny\->search_by_sql(q{SELECT id, name FROM user WHERE id = ?}, [ 1 ]);
\&    $row\->delete(\*(Aquser\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Skinny is simple \s-1DBI\s0 wrapper and simple O/R Mapper.
It aims to be lightweight, with minimal dependencies so it's easier to install.
.SH "ARCHITECTURE"
.IX Header "ARCHITECTURE"
DBIx::Skinny classes are comprised of three distinct components:
.SS "\s-1MODEL\s0"
.IX Subsection "MODEL"
The \f(CW\*(C`model\*(C'\fR is where you say
.PP
.Vb 2
\&    package MyApp::Model;
\&    use DBIx::Skinny;
.Ve
.PP
This is the entry point to using DBIx::Skinny. You connect, insert, update, delete, select stuff using this object.
.SS "\s-1SCHEMA\s0"
.IX Subsection "SCHEMA"
The \f(CW\*(C`schema\*(C'\fR is a simple class that describes your table definitions. Note that this is different from DBIx::Class terms. \s-1DBIC\s0's schema is equivalent to DBIx::Skinny's model + schema, where the actual schema information is scattered across the result classes.
.PP
In DBIx::Skinny, you simply use DBIx::Skinny::Schema's domain specific languaage to define a set of tables
.PP
.Vb 2
\&    package MyApp::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&
\&    install_table $table_name => schema {
\&        pk $primary_key_column;
\&        columns qw(
\&            column1
\&            column2
\&            column3
\&        );
\&    }
\&
\&    ... and other tables ...
.Ve
.SS "\s-1ROW\s0"
.IX Subsection "ROW"
Unlike DBIx::Class, you don't need to have a set of classes that represent a row type (i.e. \*(L"result\*(R" classes in \s-1DBIC\s0 terms). In DBIx::Skinny, the row objects are blessed into anonymous classes that inherit from DBIx::Skinny::Row, so you don't have to create these classes if you just want to use some simple queries.
.PP
If you want to define methods to be performed by your row objects, simply create a row class like so:
.PP
.Vb 2
\&    package MyApp::Model::Row::CamelizedTableName;
\&    use base qw(DBIx::Skinny::Row);
.Ve
.PP
Note that your table name will be camelized using String::CamelCase.
.SH "METHODS"
.IX Header "METHODS"
DBIx::Skinny provides a number of methods to all your classes,
.ie n .IP "$skinny\->new([\e%connection_info])" 4
.el .IP "\f(CW$skinny\fR\->new([\e%connection_info])" 4
.IX Item "$skinny->new([%connection_info])"
create your skinny instance.
It is possible to use it even by the class method.
.Sp
\&\f(CW$connection_info\fR is optional argment.
.Sp
When \f(CW$connection_info\fR is specified,
new method connect new \s-1DB\s0 connection from \f(CW$connection_info\fR.
.Sp
When \f(CW$connection_info\fR is not specified,
it becomes use already setup connection or it doesn't do at all.
.Sp
example:
.Sp
.Vb 1
\&    my $db = Your::Model\->new;
.Ve
.Sp
or
.Sp
.Vb 7
\&    # connect new database connection.
\&    my $db = Your::Model\->new(+{
\&        dsn      => $dsn,
\&        username => $username,
\&        password => $password,
\&        connect_options => $connect_options,
\&    });
.Ve
.Sp
or
.Sp
.Vb 4
\&    my $dbh = DBI\->connect();
\&    my $db = Your::Model\->new(+{
\&        dbh => $dbh,
\&    });
.Ve
.ie n .IP "$skinny\->insert($table_name, \e%row_data)" 4
.el .IP "\f(CW$skinny\fR\->insert($table_name, \e%row_data)" 4
.IX Item "$skinny->insert($table_name, %row_data)"
insert new record and get inserted row object.
.Sp
if insert to table has auto increment then return \f(CW$row\fR object with fill in key column by last_insert_id.
.Sp
example:
.Sp
.Vb 5
\&    my $row = Your::Model\->insert(\*(Aquser\*(Aq,{
\&        id   => 1,
\&        name => \*(Aqnekokak\*(Aq,
\&    });
\&    say $row\->id; # show last_insert_id()
.Ve
.Sp
or
.Sp
.Vb 5
\&    my $db = Your::Model\->new;
\&    my $row = $db\->insert(\*(Aquser\*(Aq,{
\&        id   => 1,
\&        name => \*(Aqnekokak\*(Aq,
\&    });
.Ve
.ie n .IP "$skinny\->create($table_name, \e%row_data)" 4
.el .IP "\f(CW$skinny\fR\->create($table_name, \e%row_data)" 4
.IX Item "$skinny->create($table_name, %row_data)"
insert method alias.
.ie n .IP "$skinny\->replace($table_name, \e%row_data)" 4
.el .IP "\f(CW$skinny\fR\->replace($table_name, \e%row_data)" 4
.IX Item "$skinny->replace($table_name, %row_data)"
The data that already exists is replaced.
.Sp
example:
.Sp
.Vb 4
\&    Your::Model\->replace(\*(Aquser\*(Aq,{
\&        id   => 1,
\&        name => \*(Aqtokuhirom\*(Aq,
\&    });
.Ve
.Sp
or
.Sp
.Vb 5
\&    my $db = Your::Model\->new;
\&    my $row = $db\->replace(\*(Aquser\*(Aq,{
\&        id   => 1,
\&        name => \*(Aqtokuhirom\*(Aq,
\&    });
.Ve
.ie n .IP "$skinny\->bulk_insert($table_name, \e@rows_data)" 4
.el .IP "\f(CW$skinny\fR\->bulk_insert($table_name, \e@rows_data)" 4
.IX Item "$skinny->bulk_insert($table_name, @rows_data)"
Accepts either an arrayref of hashrefs.
each hashref should be a structure suitable
forsubmitting to a Your::Model\->insert(...) method.
.Sp
insert many record by bulk.
.Sp
example:
.Sp
.Vb 10
\&    Your::Model\->bulk_insert(\*(Aquser\*(Aq,[
\&        {
\&            id   => 1,
\&            name => \*(Aqnekokak\*(Aq,
\&        },
\&        {
\&            id   => 2,
\&            name => \*(Aqyappo\*(Aq,
\&        },
\&        {
\&            id   => 3,
\&            name => \*(Aqwalf443\*(Aq,
\&        },
\&    ]);
.Ve
.ie n .IP "$skinny\->update($table_name, \e%update_row_data, [\e%update_condition])" 4
.el .IP "\f(CW$skinny\fR\->update($table_name, \e%update_row_data, [\e%update_condition])" 4
.IX Item "$skinny->update($table_name, %update_row_data, [%update_condition])"
\&\f(CW$update_condition\fR is optional argment.
.Sp
update record.
.Sp
example:
.Sp
.Vb 3
\&    my $update_row_count = Your::Model\->update(\*(Aquser\*(Aq,{
\&        name => \*(Aqnomaneko\*(Aq,
\&    },{ id => 1 });
.Ve
.Sp
or
.Sp
.Vb 3
\&    # see) DBIx::Skinny::Row\*(Aqs POD
\&    my $row = Your::Model\->single(\*(Aquser\*(Aq,{id => 1});
\&    $row\->update({name => \*(Aqnomaneko\*(Aq});
.Ve
.ie n .IP "$skinny\->update_by_sql($sql, [\e@bind_values])" 4
.el .IP "\f(CW$skinny\fR\->update_by_sql($sql, [\e@bind_values])" 4
.IX Item "$skinny->update_by_sql($sql, [@bind_values])"
update record by specific sql. return update row count.
.Sp
example:
.Sp
.Vb 4
\&    my $update_row_count = Your::Model\->update_by_sql(
\&        q{UPDATE user SET name = ?},
\&        [\*(Aqnomaneko\*(Aq]
\&    );
.Ve
.ie n .IP "$skinny\->delete($table, \e%delete_condition)" 4
.el .IP "\f(CW$skinny\fR\->delete($table, \e%delete_condition)" 4
.IX Item "$skinny->delete($table, %delete_condition)"
delete record. return delete row count.
.Sp
example:
.Sp
.Vb 3
\&    my $delete_row_count = Your::Model\->delete(\*(Aquser\*(Aq,{
\&        id => 1,
\&    });
.Ve
.Sp
or
.Sp
.Vb 3
\&    # see) DBIx::Skinny::Row\*(Aqs POD
\&    my $row = Your::Model\->single(\*(Aquser\*(Aq, {id => 1});
\&    $row\->delete
.Ve
.ie n .IP "$skinny\->delete_by_sql($sql, \e@bind_values)" 4
.el .IP "\f(CW$skinny\fR\->delete_by_sql($sql, \e@bind_values)" 4
.IX Item "$skinny->delete_by_sql($sql, @bind_values)"
delete record by specific sql. return delete row count.
.Sp
example:
.Sp
.Vb 4
\&    my $delete_row_count = Your::Model\->delete_by_sql(
\&        q{DELETE FROM user WHERE id = ?},
\&        [1]
\&    });
.Ve
.ie n .IP "$skinny\->find_or_create($table, \e%values)" 4
.el .IP "\f(CW$skinny\fR\->find_or_create($table, \e%values)" 4
.IX Item "$skinny->find_or_create($table, %values)"
create record if not exsists record.
.Sp
return DBIx::Skinny::Row's instance object.
.Sp
example:
.Sp
.Vb 4
\&    my $row = Your::Model\->find_or_create(\*(Aqusr\*(Aq,{
\&        id   => 1,
\&        name => \*(Aqnekokak\*(Aq,
\&    });
.Ve
.Sp
\&\s-1NOTICE:\s0 find_or_create has bug.
.Sp
reproduction example:
.Sp
.Vb 4
\&    my $row = Your::Model\->find_or_create(\*(Aquser\*(Aq,{
\&        id   => 1,
\&        name => undef,
\&    });
.Ve
.Sp
In this case, it becomes an error by insert.
.Sp
If you want to do the same thing in this case,
.Sp
.Vb 9
\&    my $row = Your::Model\->single(\*(Aquser\*(Aq, {
\&        id   => 1,
\&        name => \e\*(AqIS NULL\*(Aq,
\&    })
\&    unless ($row) {
\&        Your::Model\->insert(\*(Aquser\*(Aq, {
\&            id => 1,
\&        });
\&    }
.Ve
.Sp
Because the interchangeable rear side is lost, it doesn't mend.
.ie n .IP "$skinny\->find_or_insert($table, \e%values)" 4
.el .IP "\f(CW$skinny\fR\->find_or_insert($table, \e%values)" 4
.IX Item "$skinny->find_or_insert($table, %values)"
find_or_create method alias.
.ie n .IP "$skinny\->search($table_name, [\e%search_condition, [\e%search_attr]])" 4
.el .IP "\f(CW$skinny\fR\->search($table_name, [\e%search_condition, [\e%search_attr]])" 4
.IX Item "$skinny->search($table_name, [%search_condition, [%search_attr]])"
simple search method.
search method get DBIx::Skinny::Iterator's instance object.
.Sp
see DBIx::Skinny::Iterator
.Sp
get iterator:
.Sp
.Vb 1
\&    my $itr = Your::Model\->search(\*(Aquser\*(Aq,{id => 1},{order_by => \*(Aqid\*(Aq});
.Ve
.Sp
get rows:
.Sp
.Vb 1
\&    my @rows = Your::Model\->search(\*(Aquser\*(Aq,{id => 1},{order_by => \*(Aqid\*(Aq});
.Ve
.Sp
See \*(L"\s-1ATTRIBUTES\*(R"\s0 for more information for \e%search_attr.
.ie n .IP "$skinny\->search_rs($table_name, [\e%search_condition, [\e%search_attr]])" 4
.el .IP "\f(CW$skinny\fR\->search_rs($table_name, [\e%search_condition, [\e%search_attr]])" 4
.IX Item "$skinny->search_rs($table_name, [%search_condition, [%search_attr]])"
simple search method.
search_rs method always get DBIx::Skinny::Iterator's instance object.
.Sp
This method does the same exact thing as \fIsearch()\fR except it will always return a iterator, even in list context.
.ie n .IP "$skinny\->single($table_name, \e%search_condition)" 4
.el .IP "\f(CW$skinny\fR\->single($table_name, \e%search_condition)" 4
.IX Item "$skinny->single($table_name, %search_condition)"
get one record.
give back one case of the beginning when it is acquired plural records by single method.
.Sp
.Vb 1
\&    my $row = Your::Model\->single(\*(Aquser\*(Aq,{id =>1});
.Ve
.ie n .IP "$skinny\->resultset(\e%options)" 4
.el .IP "\f(CW$skinny\fR\->resultset(\e%options)" 4
.IX Item "$skinny->resultset(%options)"
resultset case:
.Sp
.Vb 11
\&    my $rs = Your::Model\->resultset(
\&        {
\&            select => [qw/id name/],
\&            from   => [qw/user/],
\&        }
\&    );
\&    $rs\->add_where(\*(Aqname\*(Aq => {op => \*(Aqlike\*(Aq, value => "%neko%"});
\&    $rs\->limit(10);
\&    $rs\->offset(10);
\&    $rs\->order({ column => \*(Aqid\*(Aq, desc => \*(AqDESC\*(Aq });
\&    my $itr = $rs\->retrieve;
.Ve
.ie n .IP "$skinny\->count($table_name, $target_column, [\e%search_condition])" 4
.el .IP "\f(CW$skinny\fR\->count($table_name, \f(CW$target_column\fR, [\e%search_condition])" 4
.IX Item "$skinny->count($table_name, $target_column, [%search_condition])"
get simple count
.Sp
.Vb 1
\&    my $cnt = Your::Model\->count(\*(Aquser\*(Aq => \*(Aqid\*(Aq, {age => 30});
.Ve
.ie n .IP "$skinny\->search_named($sql, [\e%bind_values, [\e@sql_parts, [$table_name]]])" 4
.el .IP "\f(CW$skinny\fR\->search_named($sql, [\e%bind_values, [\e@sql_parts, [$table_name]]])" 4
.IX Item "$skinny->search_named($sql, [%bind_values, [@sql_parts, [$table_name]]])"
execute named query
.Sp
.Vb 1
\&    my $itr = Your::Model\->search_named(q{SELECT * FROM user WHERE id = :id}, {id => 1});
.Ve
.Sp
If you give ArrayRef to value, that is expanded to \*(L"(?,?,?,?)\*(R" in \s-1SQL.\s0
It's useful in case use \s-1IN\s0 statement.
.Sp
.Vb 3
\&    # SELECT * FROM user WHERE id IN (?,?,?);
\&    # bind [1,2,3]
\&    my $itr = Your::Model\->search_named(q{SELECT * FROM user WHERE id IN :ids}, {ids => [1, 2, 3]});
.Ve
.Sp
If you give \e@sql_parts,
.Sp
.Vb 3
\&    # SELECT * FROM user WHERE id IN (?,?,?) AND unsubscribed_at IS NOT NULL;
\&    # bind [1,2,3]
\&    my $itr = Your::Model\->search_named(q{SELECT * FROM user WHERE id IN :ids %s}, {ids => [1, 2, 3]}, [\*(AqAND unsubscribed_at IS NOT NULL\*(Aq]);
.Ve
.Sp
If you give table_name. It is assumed the hint that makes DBIx::Skinny::Row's Object.
.ie n .IP "$skinny\->search_by_sql($sql, [\e@bind_vlues, [$table_name]])" 4
.el .IP "\f(CW$skinny\fR\->search_by_sql($sql, [\e@bind_vlues, [$table_name]])" 4
.IX Item "$skinny->search_by_sql($sql, [@bind_vlues, [$table_name]])"
execute your \s-1SQL\s0
.Sp
.Vb 8
\&    my $itr = Your::Model\->search_by_sql(q{
\&        SELECT
\&            id, name
\&        FROM
\&            user
\&        WHERE
\&            id = ?
\&    },[ 1 ]);
.Ve
.Sp
If \f(CW$opt_table_info\fR is specified, it set table infomation to result iterator.
So, you can use table row class to search_by_sql result.
.ie n .IP "$skinny\->txn_scope" 4
.el .IP "\f(CW$skinny\fR\->txn_scope" 4
.IX Item "$skinny->txn_scope"
get transaction scope object.
.Sp
.Vb 2
\&    do {
\&        my $txn = Your::Model\->txn_scope;
\&
\&        $row\->update({foo => \*(Aqbar\*(Aq});
\&
\&        $txn\->commit;
\&    }
.Ve
.Sp
An alternative way of transaction handling based on
DBIx::Skinny::Transaction.
.Sp
If an exception occurs, or the guard object otherwise leaves the scope
before \f(CW\*(C`$txn\->commit\*(C'\fR is called, the transaction will be rolled
back by an explicit \*(L"txn_rollback\*(R" call. In essence this is akin to
using a \*(L"txn_begin\*(R"/\*(L"txn_commit\*(R" pair, without having to worry
about calling \*(L"txn_rollback\*(R" at the right places. Note that since there
is no defined code closure, there will be no retries and other magic upon
database disconnection.
.ie n .IP "$skinny\->hash_to_row($table_name, $row_data_hash_ref)" 4
.el .IP "\f(CW$skinny\fR\->hash_to_row($table_name, \f(CW$row_data_hash_ref\fR)" 4
.IX Item "$skinny->hash_to_row($table_name, $row_data_hash_ref)"
make DBIx::Skinny::Row's class from hash_ref.
.Sp
.Vb 6
\&    my $row = Your::Model\->hash_to_row(\*(Aquser\*(Aq,
\&        {
\&            id   => 1,
\&            name => \*(Aqlestrrat\*(Aq,
\&        }
\&    );
.Ve
.ie n .IP "$skinny\->data2itr($table_name, \e@rows_data)" 4
.el .IP "\f(CW$skinny\fR\->data2itr($table_name, \e@rows_data)" 4
.IX Item "$skinny->data2itr($table_name, @rows_data)"
DBIx::Skinny::Iterator is made based on \e@rows_data.
.Sp
.Vb 10
\&    my $itr = Your::Model\->data2itr(\*(Aquser\*(Aq,[
\&        {
\&            id   => 1,
\&            name => \*(Aqnekokak\*(Aq,
\&        },
\&        {
\&            id   => 2,
\&            name => \*(Aqyappo\*(Aq,
\&        },
\&        {
\&            id   => 3,
\&            name => \*(Aqwalf43\*(Aq,
\&        },
\&    ]);
\&
\&    my $row = $itr\->first;
\&    $row\->insert; # inser data.
.Ve
.ie n .IP "$skinny\->find_or_new($table_name, \e%row_data)" 4
.el .IP "\f(CW$skinny\fR\->find_or_new($table_name, \e%row_data)" 4
.IX Item "$skinny->find_or_new($table_name, %row_data)"
Find an existing record from database.
.Sp
If none exists, instantiate a new row object and return it.
.Sp
The object will not be saved into your storage until you call \*(L"insert\*(R" in DBIx::Skinny::Row on it.
.Sp
.Vb 1
\&    my $row = Your::Model\->find_or_new(\*(Aquser\*(Aq,{name => \*(Aqnekokak\*(Aq});
.Ve
.ie n .IP "$skinny\->do($sql, [$option, $bind_values])" 4
.el .IP "\f(CW$skinny\fR\->do($sql, [$option, \f(CW$bind_values\fR])" 4
.IX Item "$skinny->do($sql, [$option, $bind_values])"
execute your query.
.Sp
See) <http://search.cpan.org/dist/DBI/DBI.pm#do>
.ie n .IP "$skinny\->dbh" 4
.el .IP "\f(CW$skinny\fR\->dbh" 4
.IX Item "$skinny->dbh"
get database handle.
.ie n .IP "$skinny\->connect([\e%connection_info])" 4
.el .IP "\f(CW$skinny\fR\->connect([\e%connection_info])" 4
.IX Item "$skinny->connect([%connection_info])"
connect database handle.
.Sp
If you give \e%connection_info, create new database connection.
.ie n .IP "$skinny\->reconnect(\e%connection_info)" 4
.el .IP "\f(CW$skinny\fR\->reconnect(\e%connection_info)" 4
.IX Item "$skinny->reconnect(%connection_info)"
re connect database handle.
.Sp
If you give \e%connection_info, create new database connection.
.ie n .IP "$skinny\->\fIdisconnect()\fR" 4
.el .IP "\f(CW$skinny\fR\->\fIdisconnect()\fR" 4
.IX Item "$skinny->disconnect()"
Disconnects from the currently connected database.
.ie n .IP "$skinny\->suppress_row_objects($flag)" 4
.el .IP "\f(CW$skinny\fR\->suppress_row_objects($flag)" 4
.IX Item "$skinny->suppress_row_objects($flag)"
set row object creation mode.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.IP "order_by" 4
.IX Item "order_by"
.Vb 5
\&    { order_by => [ { id => \*(Aqdesc\*(Aq } ] }
\&    # or
\&    { order_by => { id => \*(Aqdesc\*(Aq } }
\&    # or 
\&    { order_by => \*(Aqname\*(Aq }
.Ve
.IP "for_update" 4
.IX Item "for_update"
.Vb 1
\&    { for_update => 1 }
.Ve
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
.SS "\s-1SKINNY_PROFILE\s0"
.IX Subsection "SKINNY_PROFILE"
for debugging sql.
.PP
see DBIx::Skinny::Profile
.PP
.Vb 1
\&        $ SKINNY_PROFILE=1 perl ./your_script.pl
.Ve
.SS "\s-1SKINNY_TRACE\s0"
.IX Subsection "SKINNY_TRACE"
for debugging sql.
.PP
see DBIx::Skinny::Profiler::Trace
.PP
.Vb 1
\&    $ SKINNY_TRACE=1 perl ./your_script.pl
.Ve
.SS "\s-1TRIGGER\s0"
.IX Subsection "TRIGGER"
.Vb 3
\&    my $row = $db\->insert($args);
\&    # pre_insert: ($db, $args, $table_name)
\&    # post_insert: ($db, $row, $table_name)
\&
\&    my $updated_rows_count = $db\->update($args);
\&    my $updated_rows_count = $row\->update(); # example $args: +{ id => $row\->id }
\&    # pre_update: ($db, $args, $table_name)
\&    # post_update: ($db, $updated_rows_count, $table_name)
\&
\&    my $deleted_rows_count = $db\->delete($args);
\&    my $deleted_rows_count = $row\->delete(); # example $args: +{ id => $row\->id }
\&    # pre_delete: ($db, $args, $table_name)
\&    # post_delete: ($db, $deleted_rows_count, $table_name)
.Ve
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
No bugs have been reported.
.SH "AUTHOR"
.IX Header "AUTHOR"
Atsushi Kobayashi  \f(CW\*(C`<nekokak _\|_at_\|_ gmail.com>\*(C'\fR
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
walf443 : Keiji Yoshimi
.PP
\&\s-1TBONE :\s0 Terrence Brannon
.PP
nekoya : Ryo Miyake
.PP
oinume: Kazuhiro Oinuma
.PP
fujiwara: Shunichiro Fujiwara
.PP
pjam: Tomoyuki Misonou
.PP
magicalhat
.PP
Makamaka Hannyaharamitu
.PP
nihen: Masahiro Chiba
.PP
lestrrat: Daisuke Maki
.PP
tokuhirom: Tokuhiro Matsuno
.SH "SUPPORT"
.IX Header "SUPPORT"
.Vb 1
\&  irc: #dbix\-skinny@irc.perl.org
\&
\&  ML: http://groups.google.com/group/dbix\-skinny
.Ve
.SH "REPOSITORY"
.IX Header "REPOSITORY"
.Vb 1
\&  git clone git://github.com/nekokak/p5\-dbix\-skinny.git
.Ve
.SH "LICENCE AND COPYRIGHT"
.IX Header "LICENCE AND COPYRIGHT"
Copyright (c) 2010, Atsushi Kobayashi \f(CW\*(C`<nekokak _\|_at_\|_ gmail.com>\*(C'\fR. All rights reserved.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself. See perlartistic.
