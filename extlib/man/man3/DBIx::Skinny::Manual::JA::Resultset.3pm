.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Skinny::Manual::JA::Resultset 3"
.TH DBIx::Skinny::Manual::JA::Resultset 3 "2010-11-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Skinny::Manual::JA::Resultset \- DBIx::Skinnyのresultsetの使い方
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
動的にSQLを組み立てるresultsetメソッドの各種使い方マニュアルです。
.PP
Please translate and read the person in the sphere in English.
.SH "resultsetの細かい使い方"
.IX Header "resultsetの細かい使い方"
CGIなどのアプリケーションを開発している場合、
ユーザの入力に応じたSQLを組み立てたい場合がほとんどでしょう。
.PP
その場合はresultsetメソッドを使用して、SQLを動的に組み立てていく事が可能です。
.PP
まず始めにresultsetオブジェクトを取得します。
.PP
.Vb 1
\&    my $rs = Proj::Model\->resultset;
.Ve
.PP
resultsetオブジェクトにselectするカラムを指定してみましょう。
.PP
.Vb 1
\&    $rs\->add_select(\*(Aquser.id\*(Aq => \*(Aquser_id\*(Aq);
.Ve
.PP
一つ目の引数はSELECT時に使用されるベースとなるカラム指定で
二つ目の引数はASで指定される名前になります。
.PP
この場合は
.PP
.Vb 2
\&    SELECT user.id
\&    FROM
.Ve
.PP
となります。
.PP
resultsetでSQLを組み立てている時に途中でSQLを確認したくなる場合がありますが、その場合は
.PP
.Vb 1
\&    warn $rs\->as_sql;
.Ve
.PP
とすればその時点で、どのようなSQLが組み上がるかが出力されます。
.PP
次にselectするテーブルを指定します
.PP
.Vb 1
\&    $rs\->from([\*(Aquser\*(Aq]);
\&
\&    SELECT user.id
\&    FROM user
.Ve
.PP
引数はarrayrefで複数指定する事も可能です。
.PP
.Vb 1
\&    $rs\->from([\*(Aquser\*(Aq, \*(Aqhoge\*(Aq]);
\&
\&    SELECT user.id
\&    FROM user, hoge
.Ve
.PP
次にwhere句を指定しましょう。
where句を指定するにはadd_whereメソッドを使用します。
.PP
.Vb 1
\&    user.name = ?
\&    
\&    # bind = nekokak
.Ve
.PP
なwhere句を指定するにはこのように指定します。
.PP
.Vb 1
\&    $rs\->add_where(\*(Aquser.name\*(Aq => \*(Aqnekokak\*(Aq);
\&
\&    SELECT user.id
\&    FROM user
\&    WHERE (user.name = ?)
.Ve
.PP
bindされている値を確認するにはbindメソッドを使用します。
.PP
.Vb 2
\&    use Data::Dumper;
\&    warn Dumper $rs\->bind;
\&
\&    $VAR1 = [
\&            \*(Aqnekokak\*(Aq
\&            ];
.Ve
.PP
この時点のSQLを実行する場合retrieveメソッドを使用します。
retrieveメソッドを呼び出した時点でその時点のクエリが実行されます。
.PP
.Vb 1
\&    my $itr = $rs\->retrieve;
.Ve
.PP
基本的な使い方はこのようになります。
.PP
resultsetメソッドを呼び出す段階でfromやselectするカラムが決まっている場合は
resultsetメソッドの引数で指定する事も可能です。
.PP
.Vb 9
\&    my $rs = Proj::Model\->resultset(
\&        {
\&            select => [
\&                         \*(Aquser.name\*(Aq,
\&                         \*(Aquser.id AS user_id\*(Aq,
\&                      ],
\&            from   => [\*(Aquser\*(Aq],
\&        }
\&    );
.Ve
.PP
resultsetメソッドを呼び出す時にselectするカラムを指定する場合は微妙にインタフェースがことなっています。
select時に指定したいカラムの形式そのままを指定してください。
.SH "複雑なSQLを組み上げる"
.IX Header "複雑なSQLを組み上げる"
Skinnyでもある程度複雑なSQLを組み上げることはできます。
.PP
複雑なwhere句の指定方法
.PP
\&\s-1IN/NOT\s0 INを使う場合
.PP
.Vb 2
\&    $rs\->add_where(\*(Aquser.id\*(Aq => {\*(AqIN\*(Aq => \e@user_ids});
\&    $rs\->add_where(\*(Aquser.id\*(Aq => {\*(AqNOT IN\*(Aq => \e@user_ids});
.Ve
.PP
INの場合はこのように指定する事も可能です。
.PP
.Vb 1
\&    $rs\->add_where(\*(Aquser.id\*(Aq => \e@user_ids);
.Ve
.PP
比較演算子を使う場合
.PP
.Vb 3
\&    $rs\->add_where(\*(Aquser.id\*(Aq => {\*(Aq<\*(Aq => 1});
\&    $rs\->add_where(\*(Aquser.id\*(Aq => {\*(Aq>\*(Aq => 1});
\&    $rs\->add_where(\*(Aquser.id\*(Aq => {\*(Aq!=\*(Aq => 1});
.Ve
.PP
\&\s-1IS NULL/ IS NOT\s0 NULLを指定したい場合はscalarリファレンスを指定します
.PP
.Vb 2
\&    $rs\->add_where(\*(Aquser.id\*(Aq => \e\*(AqIS NULL\*(Aq);
\&    $rs\->add_where(\*(Aquser.id\*(Aq => \e\*(AqIS NOT NULL\*(Aq);
.Ve
.PP
検索条件をorで囲みたい場合はこのように指定します
.PP
.Vb 1
\&    $rs\->add_where(\*(Aquser.id\*(Aq => [{\*(Aq>\*(Aq => 10}, {\*(Aq<\*(Aq => 100}]);
.Ve
.PP
また検索条件を明示的にandで囲みたい場合は
.PP
.Vb 1
\&    $rs\->add_where(\*(Aquser.id\*(Aq => [\*(Aq\-and\*(Aq => {\*(Aq>\*(Aq => 10}, {\*(Aq<\*(Aq => 100}]);
.Ve
.PP
このように指定します。
.PP
また演算子が固定の場合は
.PP
.Vb 1
\&    $rs\->add_where(\*(Aquser.id\*(Aq => [\*(Aq\-and\*(Aq => 1,2,3]);
.Ve
.PP
このように指定する事も可能です。でもあまり使わないでしょうね。
.PP
テーブルJOINする場合
.PP
.Vb 10
\&    $rs\->from([]);
\&    $rs\->add_join(
\&        user => [
\&            {
\&                type  => \*(Aqinner\*(Aq,
\&                table => \*(Aqbookmark\*(Aq,
\&                condition => \*(Aquser.id = bookmark.user_id\*(Aq,
\&            },
\&        ],
\&    );
\&
\&    FROM user INNER JOIN bookmark ON user.id = bookmark.user_id
.Ve
.PP
このようなJOINクエリが生成されます。
.PP
始めに$rs\->from([]);を呼び出して、from を空にしているのは
add_joinで起点となるテーブルを指定しているためです。
.PP
引数のtypeはjoinのさせ方、
.PP
tableはjoinさせるテーブル
.PP
conditionはJOIN時の条件となります。
