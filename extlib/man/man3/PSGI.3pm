.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "PSGI 3"
.TH PSGI 3 "2013-04-25" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PSGI \- Perl Web Server Gateway Interface Specification
.SH "ABSTRACT"
.IX Header "ABSTRACT"
This document specifies a standard interface between web servers and
Perl web applications or frameworks. This interface is designed to promote web application
portability and reduce the duplication of effort by web application
framework developers.
.PP
Please keep in mind that \s-1PSGI\s0 is not Yet Another web application
framework. \s-1PSGI\s0 is a specification to decouple web server environments
from web application framework code. Nor is \s-1PSGI\s0 a web application
\&\s-1API.\s0 Web application developers (end users) will not run their web
applications directly using the \s-1PSGI\s0 interface, but instead are
encouraged to use frameworks that support \s-1PSGI.\s0
.SH "TERMINOLOGY"
.IX Header "TERMINOLOGY"
.IP "Web Servers" 4
.IX Item "Web Servers"
\&\fIWeb servers\fR accept \s-1HTTP\s0 requests issued by web clients,
dispatching those requests to web applications if configured to do so,
and return \s-1HTTP\s0 responses to the request-initiating clients.
.IP "\s-1PSGI\s0 Server" 4
.IX Item "PSGI Server"
A \fI\s-1PSGI\s0 Server\fR is a Perl program providing an environment for a
\&\fI\s-1PSGI\s0 application\fR to run in.
.Sp
\&\s-1PSGI\s0 specifying an interface for web applications and the main purpose
of web applications being to be served to the Internet, a \fI\s-1PSGI\s0
Server\fR will most likely be either: part of a web server (like Apache
mod_perl), connected to a web server (with FastCGI, \s-1SCGI\s0), invoked by
a web server (as in plain old \s-1CGI\s0), or be a standalone web server
itself, written entirely or partly in Perl.
.Sp
There is, however, no requirement for a \fI\s-1PSGI\s0 Server\fR to actually be
a web server or part of one, as \fI\s-1PSGI\s0\fR only defines an interface
between the server and the application, not between the server and the
world.
.Sp
A \fI\s-1PSGI\s0 Server\fR is often also called \fI\s-1PSGI\s0 Application Container\fR
because it is similar to a \fIJava Servlet container\fR, which is Java
process providing an environment for \fIJava Servlets\fR.
.IP "Applications" 4
.IX Item "Applications"
\&\fIWeb applications\fR accept \s-1HTTP\s0 requests and return \s-1HTTP\s0 responses.
.Sp
\&\fI\s-1PSGI\s0 applications\fR are web applications conforming to the \s-1PSGI\s0 interface,
prescribing they take the form of a code reference
with defined input and output.
.Sp
For simplicity,
\&\fI\s-1PSGI\s0 Applications\fR will also be referred to as \fIApplications\fR
for the remainder of this document.
.IP "Middleware" 4
.IX Item "Middleware"
\&\fIMiddleware\fR is a \s-1PSGI\s0 application (a code reference) \fIand\fR a
\&\fIServer\fR. \fIMiddleware\fR looks like an \fIapplication\fR when called from a
\&\fIserver\fR, and it in turn can call other \fIapplications\fR. It can be thought of
a \fIplugin\fR to extend a \s-1PSGI\s0 application.
.IP "Framework developers" 4
.IX Item "Framework developers"
\&\fIFramework developers\fR are the authors of web application frameworks. They
write adapters (or engines) which accept \s-1PSGI\s0 input, run a web
application, and return a \s-1PSGI\s0 response to the \fIserver\fR.
.IP "Web application developers" 4
.IX Item "Web application developers"
\&\fIWeb application developers\fR are developers who write code on top of a web
application framework. These developers should never have to deal with \s-1PSGI\s0
directly.
.SH "SPECIFICATION"
.IX Header "SPECIFICATION"
.SS "Application"
.IX Subsection "Application"
A \s-1PSGI\s0 application is a Perl code reference. It takes exactly one
argument, the environment, and returns an array reference containing exactly
three values.
.PP
.Vb 8
\&  my $app = sub {
\&      my $env = shift;
\&      return [
\&          \*(Aq200\*(Aq,
\&          [ \*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq ],
\&          [ "Hello World" ], # or IO::Handle\-like object
\&      ];
\&  };
.Ve
.PP
\fIThe Environment\fR
.IX Subsection "The Environment"
.PP
The environment \s-1MUST\s0 be a hash reference that includes CGI-like headers, as
detailed below. The application is free to modify the environment. The
environment \s-1MUST\s0 include these keys (adopted from \s-1PEP
333\s0 <http://www.python.org/dev/peps/pep-0333/>,
Rack <http://rack.rubyforge.org/doc/files/SPEC.html> and
\&\s-1JSGI\s0 <http://jackjs.org/jsgi-spec.html>) except when they would normally be
empty.
.PP
When an environment key is described as a boolean, its value \s-1MUST\s0 conform
to Perl's notion of boolean-ness. This means that an empty string or an
explicit \f(CW0\fR are both valid false values. If a boolean key is not present, an
application \s-1MAY\s0 treat this as a false value.
.PP
The values for all \s-1CGI\s0 keys (named without a period) \s-1MUST\s0 be a scalar
string.
.PP
See below for details.
.IP "\(bu" 4
\&\f(CW\*(C`REQUEST_METHOD\*(C'\fR: The \s-1HTTP\s0 request method, such as \*(L"\s-1GET\*(R"\s0 or
\&\*(L"\s-1POST\*(R".\s0 This \fB\s-1MUST NOT\s0\fR be an empty string, and so is always
required.
.IP "\(bu" 4
\&\f(CW\*(C`SCRIPT_NAME\*(C'\fR: The initial portion of the request \s-1URL\s0's \fIpath\fR,
corresponding to the application. This tells the application its
virtual \*(L"location\*(R". This may be an empty string if the application
corresponds to the server's root \s-1URI.\s0
.Sp
If this key is not empty, it \s-1MUST\s0 start with a forward slash (\f(CW\*(C`/\*(C'\fR).
.IP "\(bu" 4
\&\f(CW\*(C`PATH_INFO\*(C'\fR: The remainder of the request \s-1URL\s0's \fIpath\fR, designating
the virtual \*(L"location\*(R" of the request's target within the
application. This may be an empty string if the request \s-1URL\s0 targets
the application root and does not have a trailing slash. This value
should be \s-1URI\s0 decoded by servers in order to be compatible with \s-1RFC 3875\s0 <http://www.ietf.org/rfc/rfc3875>.
.Sp
If this key is not empty, it \s-1MUST\s0 start with a forward slash (\f(CW\*(C`/\*(C'\fR).
.IP "\(bu" 4
\&\f(CW\*(C`REQUEST_URI\*(C'\fR: The undecoded, raw request \s-1URL\s0 line. It is the raw \s-1URI\s0
path and query part that appears in the \s-1HTTP \s0\f(CW\*(C`GET /... HTTP/1.x\*(C'\fR line
and doesn't contain \s-1URI\s0 scheme and host names.
.Sp
Unlike \f(CW\*(C`PATH_INFO\*(C'\fR, this value \fB\s-1SHOULD NOT\s0\fR be decoded by servers. It is an
application's responsibility to properly decode paths in order to map URLs to
application handlers if they choose to use this key instead of \f(CW\*(C`PATH_INFO\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`QUERY_STRING\*(C'\fR: The portion of the request \s-1URL\s0 that follows the \f(CW\*(C`?\*(C'\fR,
if any. This key \s-1MAY\s0 be empty, but \fB\s-1MUST\s0\fR always be present, even if empty.
.IP "\(bu" 4
\&\f(CW\*(C`SERVER_NAME\*(C'\fR, \f(CW\*(C`SERVER_PORT\*(C'\fR: When combined with \f(CW\*(C`SCRIPT_NAME\*(C'\fR and
\&\f(CW\*(C`PATH_INFO\*(C'\fR, these keys can be used to complete the \s-1URL.\s0 Note,
however, that \f(CW\*(C`HTTP_HOST\*(C'\fR, if present, should be used in preference
to \f(CW\*(C`SERVER_NAME\*(C'\fR for reconstructing the request \s-1URL. \s0\f(CW\*(C`SERVER_NAME\*(C'\fR
and \f(CW\*(C`SERVER_PORT\*(C'\fR \fB\s-1MUST NOT\s0\fR be empty strings, and are always
required.
.IP "\(bu" 4
\&\f(CW\*(C`SERVER_PROTOCOL\*(C'\fR: The version of the protocol the client used to
send the request. Typically this will be something like \*(L"\s-1HTTP/1.0\*(R"\s0 or
\&\*(L"\s-1HTTP/1.1\*(R"\s0 and may be used by the application to determine how to
treat any \s-1HTTP\s0 request headers.
.IP "\(bu" 4
\&\f(CW\*(C`CONTENT_LENGTH\*(C'\fR: The length of the content in bytes, as an
integer. The presence or absence of this key should correspond to the
presence or absence of \s-1HTTP\s0 Content-Length header in the request.
.IP "\(bu" 4
\&\f(CW\*(C`CONTENT_TYPE\*(C'\fR: The request's \s-1MIME\s0 type, as specified by the client.
The presence or absence of this key should correspond to the presence
or absence of \s-1HTTP\s0 Content-Type header in the request.
.IP "\(bu" 4
\&\f(CW\*(C`HTTP_*\*(C'\fR Keys: These keys correspond to the client-supplied
\&\s-1HTTP\s0 request headers. The presence or absence of these keys should
correspond to the presence or absence of the appropriate \s-1HTTP\s0 header
in the request.
.Sp
The key is obtained converting the \s-1HTTP\s0 header field name to upper
case, replacing all occurrences of hyphens \f(CW\*(C`\-\*(C'\fR with
underscores \f(CW\*(C`_\*(C'\fR and prepending \f(CW\*(C`HTTP_\*(C'\fR, as in
\&\s-1RFC 3875\s0 <http://www.ietf.org/rfc/rfc3875>.
.Sp
If there are multiple header lines sent with the same key, the server
should treat them as if they were sent in one line and combine them
with \f(CW\*(C`, \*(C'\fR, as in \s-1RFC 2616\s0 <http://www.ietf.org/rfc/rfc2616>.
.PP
A server should attempt to provide as many other \s-1CGI\s0 variables as are
applicable.  Note, however, that an application that uses any \s-1CGI\s0
variables other than the ones listed above are necessarily
non-portable to web servers that do not support the relevant
extensions.
.PP
In addition to the keys above, the \s-1PSGI\s0 environment \s-1MUST\s0 also include these
PSGI-specific keys:
.IP "\(bu" 4
\&\f(CW\*(C`psgi.version\*(C'\fR: An array reference [1,1] representing this version of
\&\s-1PSGI.\s0 The first number is the major version and the second it the minor
version.
.IP "\(bu" 4
\&\f(CW\*(C`psgi.url_scheme\*(C'\fR: A string \f(CW\*(C`http\*(C'\fR or \f(CW\*(C`https\*(C'\fR, depending on the request \s-1URL.\s0
.IP "\(bu" 4
\&\f(CW\*(C`psgi.input\*(C'\fR: the input stream. See below for details.
.IP "\(bu" 4
\&\f(CW\*(C`psgi.errors\*(C'\fR: the error stream. See below for details.
.IP "\(bu" 4
\&\f(CW\*(C`psgi.multithread\*(C'\fR: This is a boolean value, which \s-1MUST\s0 be true if the
application may be simultaneously invoked by another thread in the same
process, false otherwise.
.IP "\(bu" 4
\&\f(CW\*(C`psgi.multiprocess\*(C'\fR: This is a boolean value, which \s-1MUST\s0 be true if an
equivalent application object may be simultaneously invoked by another
process, false otherwise.
.IP "\(bu" 4
\&\f(CW\*(C`psgi.run_once\*(C'\fR: A boolean which is true if the server expects (but does not
guarantee!)  that the application will only be invoked this one time during
the life of its containing process. Normally, this will only be true for a
server based on \s-1CGI \s0(or something similar).
.IP "\(bu" 4
\&\f(CW\*(C`psgi.nonblocking\*(C'\fR: A boolean which is true if the server is calling the
application in an non-blocking event loop.
.IP "\(bu" 4
\&\f(CW\*(C`psgi.streaming\*(C'\fR: A boolean which is true if the server supports callback
style delayed response and streaming writer object.
.PP
The server or the application can store its own data in the
environment as well. These keys \s-1MUST\s0 contain at least one dot, and
\&\s-1SHOULD\s0 be prefixed uniquely.
.PP
The \f(CW\*(C`psgi.\*(C'\fR prefix is reserved for use with the \s-1PSGI\s0 core
specification, and \f(CW\*(C`psgix.\*(C'\fR prefix is reserved for officially blessed
extensions. These prefixes \fB\s-1MUST NOT\s0\fR be used by other servers or
application. See psgi-extensions for the list of
officially approved extensions.
.PP
The environment \fB\s-1MUST NOT\s0\fR contain keys named \f(CW\*(C`HTTP_CONTENT_TYPE\*(C'\fR or
\&\f(CW\*(C`HTTP_CONTENT_LENGTH\*(C'\fR.
.PP
One of \f(CW\*(C`SCRIPT_NAME\*(C'\fR or \f(CW\*(C`PATH_INFO\*(C'\fR \s-1MUST\s0 be set. When
\&\f(CW\*(C`REQUEST_URI\*(C'\fR is \f(CW\*(C`/\*(C'\fR, \f(CW\*(C`PATH_INFO\*(C'\fR should be \f(CW\*(C`/\*(C'\fR and \f(CW\*(C`SCRIPT_NAME\*(C'\fR
should be empty. \f(CW\*(C`SCRIPT_NAME\*(C'\fR \fB\s-1MUST NOT\s0\fR be \f(CW\*(C`/\*(C'\fR, but \s-1MAY\s0 be
empty.
.PP
\fIThe Input Stream\fR
.IX Subsection "The Input Stream"
.PP
The input stream in \f(CW\*(C`psgi.input\*(C'\fR is an IO::Handle\-like object which
streams the raw \s-1HTTP POST\s0 or \s-1PUT\s0 data. If it is a file handle then it
\&\s-1MUST\s0 be opened in binary mode. The input stream \fB\s-1MUST\s0\fR respond to
\&\f(CW\*(C`read\*(C'\fR and \s-1MAY\s0 implement \f(CW\*(C`seek\*(C'\fR.
.PP
Perl's built-in filehandles or IO::Handle based objects should work as-is
in a \s-1PSGI\s0 server. Application developers \fB\s-1SHOULD NOT\s0\fR inspect the type or
class of the stream. Instead, they \s-1SHOULD\s0 simply call \f(CW\*(C`read\*(C'\fR on the object.
.PP
Application developers \fB\s-1SHOULD NOT\s0\fR use Perl's built-in \f(CW\*(C`read\*(C'\fR or iterator
(\f(CW\*(C`<$fh>\*(C'\fR) to read from the input stream. Instead, application
developers should call \f(CW\*(C`read\*(C'\fR as a method (\f(CW\*(C`$fh\->read\*(C'\fR) to allow for
duck typing.
.PP
Framework developers, if they know the input stream will be used with the
built-in \fIread()\fR in any upstream code they can't touch, \s-1SHOULD\s0 use PerlIO or
a tied handle to work around with this problem.
.PP
The input stream object is expected to provide a \f(CW\*(C`read\*(C'\fR method:
.IP "read" 4
.IX Item "read"
.Vb 1
\&  $input\->read($buf, $len [, $offset ]);
.Ve
.Sp
Returns the number of characters actually read, 0 at end of file, or
undef if there was an error.
.PP
It may also implement an optional \f(CW\*(C`seek\*(C'\fR method. If
\&\f(CW\*(C`psgix.input.buffered\*(C'\fR environment is true, it \s-1MUST\s0 implement the
\&\f(CW\*(C`seek\*(C'\fR method.
.IP "seek" 4
.IX Item "seek"
.Vb 1
\&  $input\->seek($pos, $whence);
.Ve
.Sp
Returns 1 on success, 0 otherwise.
.PP
See the IO::Handle documentation for more details on exactly how these
methods should work.
.PP
\fIThe Error Stream\fR
.IX Subsection "The Error Stream"
.PP
The error stream in \f(CW\*(C`psgi.errors\*(C'\fR is an IO::Handle\-like object to
print errors. The error stream must implement a \f(CW\*(C`print\*(C'\fR method.
.PP
As with the input stream, Perl's built-in filehandles or IO::Handle based
objects should work as-is in a \s-1PSGI\s0 server. Application developers \fB\s-1SHOULD
NOT\s0\fR inspect the type or class of the stream. Instead, they \s-1SHOULD\s0 simply
call \f(CW\*(C`print\*(C'\fR on the object.
.IP "print" 4
.IX Item "print"
.Vb 1
\&  $errors\->print($error);
.Ve
.Sp
Returns true if successful.
.PP
\fIThe Response\fR
.IX Subsection "The Response"
.PP
Applications \s-1MUST\s0 return a response as either a three element array
reference, or a code reference for a delayed/streaming response.
.PP
The response array reference consists of the following elements:
.PP
Status
.IX Subsection "Status"
.PP
An \s-1HTTP\s0 status code. This \s-1MUST\s0 be an integer greater than or equal to 100,
and \s-1SHOULD\s0 be an \s-1HTTP\s0 status code as documented in \s-1RFC
2616\s0 <http://www.w3.org/Protocols/rfc2616>.
.PP
Headers
.IX Subsection "Headers"
.PP
The headers \s-1MUST\s0 be an array reference (\fBnot\fR a hash reference)
of key/value pairs. This means it \s-1MUST\s0 contain an even number of elements.
.PP
The header \fB\s-1MUST NOT\s0\fR contain a key named \f(CW\*(C`Status\*(C'\fR, nor any keys with \f(CW\*(C`:\*(C'\fR
or newlines in their name. It \fB\s-1MUST NOT\s0\fR contain any keys that end in \f(CW\*(C`\-\*(C'\fR or
\&\f(CW\*(C`_\*(C'\fR.
.PP
All keys \s-1MUST\s0 consist only of letters, digits, \f(CW\*(C`_\*(C'\fR or \f(CW\*(C`\-\*(C'\fR. All
keys \s-1MUST\s0 start with a letter. The value of the header \fB\s-1MUST\s0\fR be a
scalar string and defined. The value string \fB\s-1MUST NOT\s0\fR contain
characters below octal 037 i.e. chr(31).
.PP
If the same key name appears multiple times in an array ref, those
header lines \s-1MUST\s0 be sent to the client separately (e.g. multiple
\&\f(CW\*(C`Set\-Cookie\*(C'\fR lines).
.PP
Content-Type
.IX Subsection "Content-Type"
.PP
There \s-1MUST\s0 be a \f(CW\*(C`Content\-Type\*(C'\fR except when the \f(CW\*(C`Status\*(C'\fR is 1xx, 204
or 304, in which case there \fB\s-1MUST NOT\s0\fR be a content type.
.PP
Content-Length
.IX Subsection "Content-Length"
.PP
There \fB\s-1MUST NOT\s0\fR be a \f(CW\*(C`Content\-Length\*(C'\fR header when the \f(CW\*(C`Status\*(C'\fR is
1xx, 204 or 304.
.PP
If the Status is not 1xx, 204 or 304 and there is no \f(CW\*(C`Content\-Length\*(C'\fR header,
a \s-1PSGI\s0 server \s-1MAY\s0 calculate the content length by looking at the Body. This
value can then be appended to the list of headers returned by the application.
.PP
Body
.IX Subsection "Body"
.PP
The response body \s-1MUST\s0 be returned from the application as either
an array reference or a handle containing the response body as byte
strings. The body \s-1MUST\s0 be encoded into appropriate encodings and
\&\fB\s-1MUST NOT\s0\fR contain wide characters (> 255).
.IP "\(bu" 4
If the body is an array reference, it is expected to contain an array of lines
which make up the body.
.Sp
.Vb 1
\&  my $body = [ "Hello\en", "World\en" ];
.Ve
.Sp
Note that the elements in an array reference are \fB\s-1NOT REQUIRED\s0\fR to end
in a newline. A server \s-1SHOULD\s0 write each elements as-is to the
client, and \fB\s-1SHOULD NOT\s0\fR care if the line ends with newline or not.
.Sp
An array reference with a single value is valid. So \f(CW\*(C`[ $html ]\*(C'\fR is a valid
response body.
.IP "\(bu" 4
The body can instead be a handle, either a Perl built-in filehandle or an
IO::Handle\-like object.
.Sp
.Vb 3
\&  open my $body, "</path/to/file";
\&  open my $body, "<:via(SomePerlIO)", ...;
\&  my $body = IO::File\->new("/path/to/file");
\&
\&  # mock class that implements getline() and close()
\&  my $body = SomeClass\->new();
.Ve
.Sp
Servers \fB\s-1SHOULD NOT\s0\fR check the type or class of the body. Instead, they should
simply call \f(CW\*(C`getline\*(C'\fR to iterate over the body, and
call \f(CW\*(C`close\*(C'\fR when done.
.Sp
Servers \s-1MAY\s0 check if the body is a real filehandle using \f(CW\*(C`fileno\*(C'\fR and
\&\f(CW\*(C`Scalar::Util::reftype\*(C'\fR. If the body is real filehandle, the server \s-1MAY\s0
optimize using techniques like \fI\fIsendfile\fI\|(2)\fR.
.Sp
The body object \s-1MAY\s0 also respond to a \f(CW\*(C`path\*(C'\fR method. This method is
expected to return the path to a file accessible by the server. This allows
the server to use this information instead of a file descriptor number to
serve the file.
.Sp
Servers \s-1SHOULD\s0 set the \f(CW$/\fR special variable to the buffer size when
reading content from \f(CW$body\fR using the \f(CW\*(C`getline\*(C'\fR method. This is done by
setting \f(CW$/\fR with a reference to an integer (\f(CW\*(C`$/ = \e8192\*(C'\fR).
.Sp
If the body filehandle is a Perl built-in filehandle IO::Handle object,
they will respect this value. Similarly, an object which provides the same \s-1API
MAY\s0 also respect this special variable, but are not required to do so.
.SS "Delayed Response and Streaming Body"
.IX Subsection "Delayed Response and Streaming Body"
The \s-1PSGI\s0 interface allows applications and servers to provide a
callback-style response instead of the three-element array
reference. This allows for a delayed response and a streaming body
(server push).
.PP
This interface \s-1SHOULD\s0 be implemented by \s-1PSGI\s0 servers, and
\&\f(CW\*(C`psgi.streaming\*(C'\fR environment \s-1MUST\s0 be set to true in such servers.
.PP
To enable a delayed response, the application \s-1SHOULD\s0 return a
callback as its response. An application \s-1MAY\s0 check if the
\&\f(CW\*(C`psgi.streaming\*(C'\fR environment is true and falls back to the direct
response if it isn't.
.PP
This callback will be called with \fIanother\fR subroutine reference (referred to
as the \fIresponder\fR from now on) as its only argument. The \fIresponder\fR
should in turn be called with the standard three element array reference
response. This is best illustrated with an example:
.PP
.Vb 2
\&  my $app = sub {
\&      my $env = shift;
\&
\&      # Delays response until it fetches content from the network
\&      return sub {
\&          my $responder = shift;
\&
\&          fetch_content_from_server(sub {
\&              my $content = shift;
\&              $responder\->([ 200, $headers, [ $content ] ]);
\&          });
\&      };
\&  };
.Ve
.PP
An application \s-1MAY\s0 omit the third element (the body) when calling
the \fIresponder\fR. If the body is omitted, the \fIresponder\fR \s-1MUST\s0
return \fIyet another\fR object which implements \f(CW\*(C`write\*(C'\fR and \f(CW\*(C`close\*(C'\fR
methods. Again, an example illustrates this best.
.PP
.Vb 2
\&  my $app = sub {
\&      my $env = shift;
\&
\&      # immediately starts the response and stream the content
\&      return sub {
\&          my $responder = shift;
\&          my $writer = $responder\->(
\&              [ 200, [ \*(AqContent\-Type\*(Aq, \*(Aqapplication/json\*(Aq ]]);
\&
\&          wait_for_events(sub {
\&              my $new_event = shift;
\&              if ($new_event) {
\&                  $writer\->write($new_event\->as_json . "\en");
\&              } else {
\&                  $writer\->close;
\&              }
\&          });
\&      };
\&  };
.Ve
.PP
This delayed response and streaming \s-1API\s0 is useful if you want to
implement a non-blocking I/O based server streaming or long-poll Comet
push technology, but could also be used to implement unbuffered writes
in a blocking server.
.SS "Middleware"
.IX Subsection "Middleware"
A \fImiddleware\fR component takes another \s-1PSGI\s0 application and runs it. From the
perspective of a server, a middleware component is a \s-1PSGI\s0 application. From
the perspective of the application being run by the middleware component, the
middleware is the server. Generally, this will be done in order to implement
some sort of pre-processing on the \s-1PSGI\s0 environment hash or post-processing on
the response.
.PP
Here's a simple example that appends a special \s-1HTTP\s0 header
\&\fIX\-PSGI-Used\fR to any \s-1PSGI\s0 application.
.PP
.Vb 7
\&  # $app is a simple PSGI application
\&  my $app = sub {
\&      my $env = shift;
\&      return [ \*(Aq200\*(Aq,
\&               [ \*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq ],
\&               [ "Hello World" ] ];
\&  };
\&
\&  # $xheader is a piece of middleware that wraps $app
\&  my $xheader = sub {
\&      my $env = shift;
\&      my $res = $app\->($env);
\&      push @{$res\->[1]}, \*(AqX\-PSGI\-Used\*(Aq => 1;
\&      return $res;
\&  };
.Ve
.PP
Middleware \s-1MUST\s0 behave exactly like a \s-1PSGI\s0 application from the perspective
of a server. Middleware \s-1MAY\s0 decide not to support the streaming interface
discussed earlier, but \s-1SHOULD\s0 pass through the response types that it doesn't
understand.
.SH "CHANGELOGS"
.IX Header "CHANGELOGS"
1.1: 2010.02.xx
.IP "\(bu" 4
Added optional \s-1PSGI\s0 keys as extensions: \f(CW\*(C`psgix.logger\*(C'\fR and \f(CW\*(C`psgix.session\*(C'\fR.
.IP "\(bu" 4
\&\f(CW\*(C`psgi.streaming\*(C'\fR \s-1SHOULD\s0 be implemented by \s-1PSGI\s0 servers, rather than \fB\s-1MAY\s0\fR.
.IP "\(bu" 4
\&\s-1PSGI\s0 keys \f(CW\*(C`psgi.run_once\*(C'\fR, \f(CW\*(C`psgi.nonblocking\*(C'\fR and \f(CW\*(C`psgi.streaming\*(C'\fR
\&\s-1MUST\s0 be set by \s-1PSGI\s0 servers.
.IP "\(bu" 4
Removed \f(CW\*(C`poll_cb\*(C'\fR from writer methods.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
Some parts of this specification are adopted from the following specifications.
.IP "\(bu" 4
\&\s-1PEP333\s0 Python Web Server Gateway Interface <http://www.python.org/dev/peps/pep\-0333>
.IP "\(bu" 4
Rack <http://rack.rubyforge.org/doc/SPEC.html>
.IP "\(bu" 4
\&\s-1JSGI\s0 Specification <http://jackjs.org/jsgi\-spec.html>
.PP
I'd like to thank authors of these great documents.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tatsuhiko Miyagawa <miyagawa@bulknews.net>
.SH "CONTRIBUTORS"
.IX Header "CONTRIBUTORS"
The following people have contributed to the \s-1PSGI\s0 specification and
Plack implementation by commiting their code, sending patches,
reporting bugs, asking questions, suggesting useful advices,
nitpicking, chatting on \s-1IRC\s0 or commenting on my blog (in no particular
order):
.PP
.Vb 10
\&  Tokuhiro Matsuno
\&  Kazuhiro Osawa
\&  Yuval Kogman
\&  Kazuho Oku
\&  Alexis Sukrieh
\&  Takatoshi Kitano
\&  Stevan Little
\&  Daisuke Murase
\&  mala
\&  Pedro Melo
\&  Jesse Luehrs
\&  John Beppu
\&  Shawn M Moore
\&  Mark Stosberg
\&  Matt S Trout
\&  Jesse Vincent
\&  Chia\-liang Kao
\&  Dave Rolsky
\&  Hans Dieter Pearcey
\&  Randy J Ray
\&  Benjamin Trott
\&  Max Maischein
\&  Slaven Rezić
\&  Marcel Grünauer
\&  Masayoshi Sekimura
\&  Brock Wilcox
\&  Piers Cawley
\&  Daisuke Maki
\&  Kang\-min Liu
\&  Yasuhiro Matsumoto
\&  Ash Berlin
\&  Artur Bergman
\&  Simon Cozens
\&  Scott McWhirter
\&  Jiro Nishiguchi
\&  Masahiro Chiba
\&  Patrick Donelan
\&  Paul Driver
\&  Florian Ragwitz
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright Tatsuhiko Miyagawa, 2009\-2011.
.PP
This document is licensed under the Creative Commons license by-sa.
