.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Skinny::Manual::JA::Intro 3"
.TH DBIx::Skinny::Manual::JA::Intro 3 "2010-11-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Skinny::Manual::JA::Intro \- DBIx::Skinnyの日本語ドキュメント
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Skinnyの総合的な使い方を網羅するマニュアルです。
.PP
Please translate and read the person in the sphere in English.
.SH "注意"
.IX Header "注意"
現在SkinnyはMySQLとSQLiteとPostgreSQLとOracleをサポートしています。
.PP
他のDBDを使いたい場合は、
DBIx::Skinny::DBD::*を作っていただく必要があります。
.PP
まだまだα版なので色々変わる事があるかもしれません。
.SS "Skinnyの基本クラスの定義"
.IX Subsection "Skinnyの基本クラスの定義"
Skinnyを操作するClassを定義します。
.PP
例えばProjというプロジェクトでSkinnyを使う場合
.PP
.Vb 7
\&    package Proj::Model;
\&    use DBIx::Skinny connect_info => +{
\&        dsn => \*(Aqdbi:SQLite:\*(Aq,
\&        username => \*(Aq\*(Aq,
\&        password => \*(Aq\*(Aq,
\&    };
\&    1;
.Ve
.PP
このようなClassを用意します。
ちなみに、DBIx::Skinnyをuseすると
.PP
use strict;
.PP
use warnings;
.PP
された事と同じ状態にします。
.PP
DBIx::Skinnyをuseする時の引数でdsnなどDBの接続に必要な情報を渡す事ができます。
.PP
\&.pmファイルに直接dsnなどを書きたくない場合は
.PP
.Vb 3
\&    package Proj::Model;
\&    use DBIx::Skinny;
\&    1;
.Ve
.PP
DBIx::Skinnyをuseする時の引数にdsnなどを書かずにClassを作成しておき、
DBにクエリを投げる前に
.PP
.Vb 1
\&    Proj::Model\->connect_info(....); # connect_infoを設定する
.Ve
.PP
もしくは
.PP
.Vb 1
\&    Proj::Model\->connect(....): # connectメソッドをdsnなどの引数ともに呼び出す
.Ve
.PP
もしくは
.PP
.Vb 1
\&    my $model = Proj::Model\->new($connection_info); # インスタンスを作りつつコネクション情報を設定する
.Ve
.PP
としてやればよいです。
.PP
また元々dbのhandlerを別で持っている場合でそれを使い回したい場合は
.PP
.Vb 1
\&    Proj::Model\->set_dbh($dbh);
.Ve
.PP
このようにset_dbhにhandlerを渡してやれば内部で持っているdatabase handlerを置き換える事ができます。
.SS "スキーマクラスの定義"
.IX Subsection "スキーマクラスの定義"
Skinnyでは他のORマッパーと同じように各tableに対応するschemaの設定を書く必要があります。
.PP
例えばuserテーブルがある場合
.PP
.Vb 2
\&    package Proj::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    
\&    install_table \*(Aquser\*(Aq => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id guid login_id login_pw name mail created_at updated_at
\&        /;
\&    };
\&    1;
.Ve
.PP
DBIx::Skinny::SchemaをuseするとSchemaを構成するために必要なmethodがexportされます。
.PP
ちなみに、DBIx::Skinny::Schemaでもuseすると
.PP
use strict;
.PP
use warnings;
.PP
された事と同じ状態にします。
.PP
この例ではuserテーブルの
プライマリキーはid
各カラムにはid/guid/login_id/login_pw/name/mail/created_at/updated_at
がある事を定義しています。
.PP
Skinnyでは他のORマッパーと異なり、テーブル毎にClassを作る必要はありません。
.PP
この例の場合Proj::Model::Schemaに全てのテーブル情報を記載します。
.PP
\fIマルチバイトな値を扱うカラムについて\fR
.IX Subsection "マルチバイトな値を扱うカラムについて"
.PP
このuserテーブルの例でnameカラムがマルチバイトな文字列が入る場合でutf8flagの処理を自動で行いたい場合は
.PP
.Vb 2
\&    package Proj::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    
\&    install_utf8_columns qw/name/;
\&    install_table \*(Aquser\*(Aq => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id guid login_id login_pw name mail created_at updated_at
\&        /;
\&    };
\&    1;
.Ve
.PP
このようにinstall_utf8_columnsに対象となるカラム名を設定します。
.PP
ここで注意が必要なのですが、Skinnyはルールベースな設計しています。
.PP
Skinnyの根本思想としてはモジュール利用者が好きに生のSQLを実行して、
その結果をちょっといい感じのオブジェクトに纏めて
ちょっと楽をしようというものです。
.PP
脱線しましたがinstall_utf8_columnsに対象となるカラム名を設定するのですが
この設定はSkinnyで取り扱う全テーブルに対しての設定となります。
.PP
ですのでuserテーブル以外のテーブルにnameカラムがあった場合、
install_utf8_columnsにnameを設定しているとuserテーブル以外のテーブルのnameカラムもutf8flag周りの処理が行われます。
.PP
\fIinflate/deflateの処理について\fR
.IX Subsection "inflate/deflateの処理について"
.PP
Skinnyにもinflate/deflateの処理を書く事ができます
.PP
userテーブルの例の場合でcreated_at/updated_atなカラムをDateTimeでinflate/deflateしたい場合は
.PP
.Vb 6
\&    package Proj::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    use DateTime;
\&    use DateTime::Format::Strptime;
\&    use DateTime::Format::MySQL;
\&    use DateTime::TimeZone;
\&    
\&    my $timezone = DateTime::TimeZone\->new(name => \*(AqAsia/Tokyo\*(Aq);
\&    install_inflate_rule \*(Aq^.+_at$\*(Aq => callback {
\&        inflate {
\&            my $value = shift;
\&            my $dt = DateTime::Format::Strptime\->new(
\&                pattern   => \*(Aq%Y\-%m\-%d %H:%M:%S\*(Aq,
\&                time_zone => $timezone,
\&            )\->parse_datetime($value);
\&            return DateTime\->from_object( object => $dt );
\&        };
\&        deflate {
\&            my $value = shift;
\&            return DateTime::Format::MySQL\->format_datetime($value);
\&        };
\&    };
\&    
\&    install_table \*(Aquser\*(Aq => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id guid login_id login_pw name mail created_at updated_at
\&        /;
\&    };
\&    1;
.Ve
.PP
例えばこのように書きます。
.PP
install_inflate_ruleに対象となるカラムのルールを書きます。
ここは正規表現で書く事ができます。
.PP
install_inflate_ruleもinstall_utf8_columnsと同様Skinnyで扱う全テーブルが対象となります。
.PP
\fItriggerについて\fR
.IX Subsection "triggerについて"
.PP
Skinnyにもinsert/update/deleteなどを行った場合にtriggerによるHookをかける事ができます。
.PP
例えばinsert時にcreated_atを自動で設定するtriggerをかけたい場合は
.PP
.Vb 3
\&    package Proj::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    use DateTime;
\&    
\&    install_table \*(Aquser\*(Aq => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id guid login_id login_pw name mail created_at updated_at
\&        /;
\&        trigger pre_insert => sub {
\&            my ( $class, $args ) = @_;
\&            $args\->{created_at} ||= DateTime\->now;
\&        };
\&    };
\&    1;
.Ve
.PP
例えばこのように書きます
.PP
現在トリガーを設定できるポイントは
.PP
pre_insert / post_insert / pre_update / post_update / pre_delete / post_delete
.PP
があります
.PP
トリガーはテーブル単位で設定する事ができます
.PP
またトリガーは同じHookポイントに対して複数設定する事もできます。
同じHookポイントに複数設定した場合は設定した順番に実行されます。
.SS "new"
.IX Subsection "new"
Skinnyはインスタンスを作っても作らなくてもDBを操作する事もできるようになっています。
.PP
インスタンスを作ってDB操作を行う場合
.PP
.Vb 2
\&    my $model = Proj::Model\->new;
\&    $model\->do();
.Ve
.PP
インスタンスを作らずにDB操作を行う場合
.PP
.Vb 1
\&    Proj::Model\->do()
.Ve
.PP
インスタンスを作る場合と作らない場合の最大の違いは
インスタンスを作った場合はそのコネクションはインスタンスに紐付けられ
インスタンスを作らない場合はコネクションはクラスに紐付けられることです。
.PP
WEBでリクエスト毎にDBコネクションを管理したい場合はインスタンスを作り、
バッチ処理などで特別DBコネクションを管理する必要がない場合はインスタンスを作らずに使えば良いです。
.SS "connection_info / connect /reconnect / set_dbh"
.IX Subsection "connection_info / connect /reconnect / set_dbh"
\fIconnection_info\fR
.IX Subsection "connection_info"
.PP
connect_infoメソッドではDB接続情報を設定します
.PP
.Vb 10
\&    Proj::Model\->connection_info({
\&        dsn      => \*(Aqdbi:mysql:test\*(Aq,
\&        username => \*(Aqusername\*(Aq,
\&        password => \*(Aqpassword\*(Aq
\&        connect_options => +{
\&            RaiseError => 1,
\&            PrintError => 0,
\&            AutoCommit => 1,
\&        },
\&    });
.Ve
.PP
connection_infoメソッドを呼び出した時点ではDBの接続は確立されません。
.PP
また引数で渡しているconnect_optionsは特に指定されなければ、
内部では
.PP
RaiseError: 1
.PP
PrintError: 0
.PP
AutoCommit: 1
.PP
でDBに接続されます。
.PP
\fIconnect\fR
.IX Subsection "connect"
.PP
明示的にDB接続を行いたい場合はconnectメソッドを使用します。
.PP
.Vb 10
\&    Proj::Model\->connect({
\&        dsn      => \*(Aqdbi:mysql:test\*(Aq,
\&        username => \*(Aqusername\*(Aq,
\&        password => \*(Aqpassword\*(Aq
\&        connect_options => +{
\&            RaiseError => 1,
\&            PrintError => 0,
\&            AutoCommit => 1,
\&        },
\&    });
.Ve
.PP
\fIreconnect\fR
.IX Subsection "reconnect"
.PP
一度DBに接続された状態で他のDBに接続しなおしたい場合は
reconnectメソッドを使用します。
.PP
.Vb 10
\&    Proj::Model\->reconnect({
\&        dsn      => \*(Aqdbi:mysql:test\*(Aq,
\&        username => \*(Aqusername\*(Aq,
\&        password => \*(Aqpassword\*(Aq
\&        connect_options => +{
\&            RaiseError => 1,
\&            PrintError => 0,
\&            AutoCommit => 1,
\&        },
\&    });
.Ve
.PP
reconnectメソッドを呼び出すと呼び出す前まで保持していたdatabase handlerは破棄されます。
.PP
\fIset_dbh\fR
.IX Subsection "set_dbh"
.PP
既にdatabase handlerを別で管理しており、Skinnyでそのhandlerを使いたい場合は
set_dbhメソッドを使用します。
.PP
.Vb 1
\&    Proj::Model\->set_dbh($dbh);
.Ve
.PP
set_dbhメソッドを呼び出すと呼び出す前まで保持していたdatabase handlerは破棄されます。
.SS "dbh"
.IX Subsection "dbh"
dbhメソッドを呼び出すとその時点でのdatabase handlerが取得できます。
.PP
.Vb 1
\&    my $dbh = Proj::Model\->dbh;
.Ve
.SS "do"
.IX Subsection "do"
doメソッドは$dbh\->doのショートカットになっています。
.PP
.Vb 6
\&    Proj::Model\->do(q{
\&        CREATE TABLE foo (
\&            id   INT,
\&            name TEXT
\&        )
\&    });
.Ve
.SS "insert / create"
.IX Subsection "insert / create"
userテーブルにレコードをinsertするには以下のようにします。
.PP
.Vb 4
\&    my $row = Proj::Model\->insert(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
.Ve
.PP
insertメソッドの返り値はSkinnyのRowクラスになっていますので
.PP
.Vb 2
\&    print $row\->name; # nekokak
\&    print $row\->mail; # nekokak _at_ gmail.com
.Ve
.PP
このようにカラム名をメソッドとしてデータにアクセスできます
.PP
また、createメソッドはinsertメソッドのエイリアスになっているのでどちらでもOKです
.PP
.Vb 4
\&    my $row = Proj::Model\->create(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
.Ve
.SS "update"
.IX Subsection "update"
userテーブルのレコードをupdateするには以下のようにします。
.PP
.Vb 1
\&    Proj::Model\->update(\*(Aquser\*(Aq, {name => \*(Aqyappo\*(Aq}, {id => 1})
.Ve
.PP
一つ目のhashrefが更新する情報で
二つ目のhashrefが更新対象とするレコードの条件です。
.PP
また、Rowクラスから直接updateをかけることもできます。
.PP
.Vb 5
\&    my $row = Proj::Model\->insert(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
\&    $row\->update({name => \*(Aqyappo\*(Aq});
.Ve
.SS "delete"
.IX Subsection "delete"
userテーブルのレコードをdeleteするには以下のようにします
.PP
.Vb 1
\&    Proj::Model\->delete(\*(Aquser\*(Aq, {id => 1});
.Ve
.PP
hashrefでdelete対象とするレコードの条件を指定できます。
.PP
またdeleteメソッドもupdateメソッドと同じくRowクラスから直接deleteをかけることもできます。
.PP
.Vb 5
\&    my $row = Proj::Model\->insert(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
\&    $row\->delete;
.Ve
.SS "bulk_insert"
.IX Subsection "bulk_insert"
userテーブルに一気に複数行insertをかけたい場合は以下のようにします。
.PP
.Vb 12
\&    Proj::Model\->bulk_insert(\*(Aquser\*(Aq,
\&        [
\&            {
\&                name => \*(Aqnekokak\*(Aq,
\&                mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&            },
\&            {
\&                name => \*(Aqyappo\*(Aq,
\&                mail => \*(Aqyappo _at_ example.com\*(Aq,
\&            },
\&        ]
\&    );
.Ve
.PP
bulk_insertでは現状insertのトリガーは利用できませんのでご注意ください。
.SS "find_or_create / find_or_insert"
.IX Subsection "find_or_create / find_or_insert"
userテーブルに指定した条件のレコードが存在すればその行をselectし
レコードが存在しなければinsertを行うことが出来ます。
.PP
.Vb 4
\&    my $row = Proj::Model\->find_or_create(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
.Ve
.PP
また、find_or_insertメソッドはfind_or_createメソッドのエイリアスになっているのでどちらでもOKです
.PP
.Vb 4
\&    my $row = Proj::Model\->find_or_insert(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
.Ve
.SS "single / search / search_named /search_by_sql / count"
.IX Subsection "single / search / search_named /search_by_sql / count"
\fIsingle\fR
.IX Subsection "single"
.PP
userテーブル１行だけ取得したい場合に使用します。
.PP
.Vb 1
\&    my $row = Proj::Model\->single(\*(Aquser\*(Aq,{name => \*(Aqnekokak\*(Aq});
.Ve
.PP
\fIsearch\fR
.IX Subsection "search"
.PP
userテーブルに対してselectクエリを発行する場合にsearchメソッドを使用します。
.PP
.Vb 6
\&    my $itr = Proj::Model\->search(\*(Aquser\*(Aq,
\&        {
\&            name => \*(Aqnekokak\*(Aq,
\&        },
\&        { }
\&    );
.Ve
.PP
二つ目のhashrefに検索条件
三つ目のhashrefにorderやlimitなどのオプションを渡せます。
.PP
searchメソッドはメソッドの返り値をスカラーコンテキストで受けるかリストコンテキストでうけるかで
返り値の情報が変わりま。
スカラーコンテキストで受けた場合はDBIx::Skinny::Iteratorが取得でき、
リストコンテキストで受けた場合は結果Rowの配列を取得することができます。
.PP
細かい検索条件の指定の仕方はDBIx::Class::Manual::JA::Resultsetを参考にしてください。
.PP
\fIsearch_named\fR
.IX Subsection "search_named"
.PP
selectクエリを発行する場合でnamedなプレスホルダーを使いつつ
SQLを実行させることができます。
.PP
.Vb 1
\&    my $itr = Proj::Model\->search_named(q{SELECT * FROM user WHERE id > :id}, {id => 1});
.Ve
.PP
一つ目の引数に発行したいクエリ
二つ目の引数にはプレスホルダーに相当するHashrefを指定します。
この例の場合':id'に相当する部分がHashrefのidのvalueである1と置き換えられます。
.PP
また、%sなどを指定してSQLを書き換える事も可能です。
.PP
.Vb 1
\&    my $itr = Proj::Model\->search_named(q{SELECT * FROM user WHERE id > :id LIMIT %s}, {id => 1}, [10]);
.Ve
.PP
LIMITの値などBindの値で置き換えられない場合などに使用します。
三つ目の引数にarrayrefで指定してください。
.PP
.Vb 1
\&    my $itr = Proj::Model\->search_named(q{SELECT * FROM user WHERE id > :id LIMIT %s}, {id => 1}, [10], \*(Aquser\*(Aq);
.Ve
.PP
また四つ目の引数はオプションでクエリのベースとなっているテーブルを指定することができます。
これは必須項目では有りません。
.PP
\fIsearch_by_sql\fR
.IX Subsection "search_by_sql"
.PP
selectクエリを発行する場合に生のを使うにはこのメソッドを使います。
.PP
.Vb 1
\&    my $itr = Proj::Model\->search_by_sql(q{SELECT * FROM user WHERE id = ?}, [1], \*(Aquser\*(Aq);
.Ve
.PP
一つ目の引数に発行したいクエリ
二つ目の引数に発行したいクエリに使用するbindの値
三つ目の引数はオプションです。指定しなくてもよいです。別の項目で細かく説明します。
.PP
\fIcount\fR
.IX Subsection "count"
.PP
userテーブルのcountをとりたい場合はcountメソッドを使用します。
.PP
.Vb 1
\&    my $count = Porj::Model\->count(\*(Aquser\*(Aq , \*(Aqid\*(Aq, {name => \*(Aqnekokak\*(Aq});
.Ve
.PP
二つ目の引数がcountを取る対象となるカラム情報で
三つ目の引数がcountを取る条件となります。
.SS "resultset"
.IX Subsection "resultset"
DBIx::Skinny::Manual::JA::Resultsetを参照してください。
.SS "トランザクション"
.IX Subsection "トランザクション"
Skinnyではトランザクションの仕組みを簡単にサポートしています。
トランザクションを有効にした処理を書きたい場合は以下のようにします。
.PP
.Vb 1
\&    my $txn = Porj::Model\->txn_scope;
\&    
\&    my $row = Proj::Model\->single(\*(Aquser\*(Aq, {id => 1});
\&    $row\->set({name => \*(Aqnekokak\*(Aq});
\&    $row\->update;
\&    
\&    $txn\->commit;
.Ve
.PP
Skinnyのトランザクションサポートはtxn_scopeメソッドで取得したオブジェクトが有効な間、
トランザクションの面倒をみます。
\&\f(CW$txn\fR\->commitを実行するまでの間にデータベースに対して複数の更新クエリを実行させます。
\&\f(CW$txn\fR\->commitが実行されずに$txnオブジェクトが亡くなってしまった場合、
それまでの更新はすべてrollbackされます。
.PP
txn_scopeメソッドを使わずに
.PP
.Vb 1
\&    Proj::Model\->txn_begin;
\&    
\&    my $row = Proj::Model\->single(\*(Aquser\*(Aq, {id => 1});
\&    $row\->set({name => \*(Aqnekokak\*(Aq});
\&    $row\->update;
\&    
\&    Proj::Model\->txn_commit;
\&    Proj::Model\->txn_end;
.Ve
.PP
自前でトランザクションを管理する事も可能です。
.PP
当然ですがトランザクション機能をつかうにはRDBMSがトランザクションの機能をサポートしている必要があります。
MySQLをお使いの場合はInnoDBを使ってください。
.SS "メソッドの追加(Mixin)"
.IX Subsection "メソッドの追加(Mixin)"
DBIx::Skinny::Mixinモジュールを利用すれば、
Proj::Modelにメソッドを追加できるようになります。
.PP
例えば
.PP
.Vb 4
\&    package Proj::Model;
\&    use DBIx::Skinny;
\&    use DBIx::Skinny::Mixin modules => [\*(Aq+Mixin::Foo\*(Aq];
\&    1;
\&    
\&    package Mixin::Foo;
\&    sub register_method {
\&        +{
\&            foo => sub { \*(Aqfoo\*(Aq },
\&        };
\&    }
.Ve
.PP
このようにMixin::Fooで定義されたregister_methodの内容に従って
Proj::Modelにメソッドがexportされます。
.PP
この例の場合fooというメソッドがexportされるので
.PP
.Vb 1
\&    Proj::Model\->foo;
.Ve
.PP
とアクセスする事ができます。
.SS "Rowオブジェクトへのメソッド追加"
.IX Subsection "Rowオブジェクトへのメソッド追加"
Proj::Model::Row::{Table}のようなファイルを用意すること、
SkinnyはIteratorから返されるRowオブエクト
のベースとなるクラスでProj::Model::Row::{Table}を使う事ができます。
.PP
Tableクラスが見つからない場合や、発行したクエリからどのテーブルクラスを使うべきか判断できない場合は
発行するSQLをDigest::SHA1でハッシュした値をつかったANONクラスを作成し使用します。
.PP
Tableクラスを用意することで、そのクラスにメソッドを定義できます。
.PP
.Vb 9
\&    package Proj::Model::Row::User;
\&    use strict;
\&    use warnings;
\&    use utf8;
\&    use base \*(AqDBIx::Skinny::Row\*(Aq;
\&    sub foo {
\&        say \*(Aqfoo\*(Aq;
\&    }
\&    1;
.Ve
.PP
fooメソッドを定義しておく事で
.PP
.Vb 1
\&    $row\->foo;
.Ve
.PP
と呼び出す事が可能です。
.PP
またこの仕組みを利用すれば、リレーションを独自に実装する事も可能です。
.PP
例えば、User has_many Blogの場合
.PP
.Vb 6
\&    package Proj::Model::Row::User;
\&    use base \*(AqDBIx::Skinny::Row\*(Aq;
\&    sub blogs {
\&        my $self = shift;
\&        $self\->{skinny}\->search(\*(Aqblog\*(Aq,{user_id => $self\->id});
\&    }
.Ve
.PP
このように書く事ができ、
.PP
.Vb 1
\&    $user\->blogs;
.Ve
.PP
このようにアクセスさせる事が可能です。
