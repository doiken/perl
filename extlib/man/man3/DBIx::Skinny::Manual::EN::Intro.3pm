.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "DBIx::Skinny::Manual::EN::Intro 3"
.TH DBIx::Skinny::Manual::EN::Intro 3 "2010-11-08" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Skinny::Manual::EN::Intro \- Intro to DBIx::Skinny
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "Caution"
.IX Header "Caution"
DBIx::Skinny runs on MySQL, SQLite, PostgreSQL and Oracle.
.PP
However it is designed to be extensible to other databases.
.PP
Be aware that APIs may change \- this is alpha software!
.SH "Base Class Defintions"
.IX Header "Base Class Defintions"
Let's work with an example project called \f(CW\*(C`Proj\*(C'\fR. Your Skinny 
model for this project would be:
.PP
.Vb 7
\&    package Proj::Model;
\&    use DBIx::Skinny conect_info => +{
\&        dsn => \*(Aqdbi:SQLite:\*(Aq,
\&        username => \*(Aq\*(Aq,
\&        password => \*(Aq\*(Aq,
\&    };
\&    1;
.Ve
.SS "\s-1DSN\s0 file usage"
.IX Subsection "DSN file usage"
If you want to directly use \s-1DSN\s0 files then you can create your model like this:
.PP
.Vb 3
\&    package Proj::Model;
\&    use DBIx::Skinny;
\&    1;
.Ve
.SS "\->connect_info"
.IX Subsection "->connect_info"
.Vb 1
\&    Proj::Model\->connect_info(....);
.Ve
.SS "\->connect"
.IX Subsection "->connect"
.Vb 1
\&    Proj::Model\->connect(....);
.Ve
.SS "Proj::Model\->new($connection_info)"
.IX Subsection "Proj::Model->new($connection_info)"
.Vb 1
\&    my $model = Proj::Model\->new($connection_info);
.Ve
.SS "\->set_dbh"
.IX Subsection "->set_dbh"
.Vb 1
\&    Proj::Model\->set_dbh($dbh);
.Ve
.SH "Schema class definition"
.IX Header "Schema class definition"
The recommended way to define your schema classes is automatically via
DBIx::Skinny::Schema::Loader. However, read on for info about
manual setup.
.PP
.Vb 2
\&    package Proj::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    
\&    install_table \*(Aquser\*(Aq => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id guid login_id login_pw name mail created_at updated_at
\&        /;
\&    };
\&    1;
.Ve
.PP
Unlike most \s-1OR\s0 mappers which require a class for every table, in Skinny
you can install all your tables in a single class.
.PP
\fIDealing with multi-byte (utf\-8) values for a column\fR
.IX Subsection "Dealing with multi-byte (utf-8) values for a column"
.PP
Automatic processing of columns is achieved via \f(CW\*(C`install_utf8_columns\*(C'\fR:
.PP
.Vb 2
\&    package Proj::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    
\&    install_utf8_columns qw/name/;
\&    install_table \*(Aquser\*(Aq => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id guid login_id login_pw name mail created_at updated_at
\&        /;
\&    };
\&    1;
.Ve
.PP
Note that the \f(CW\*(C`name\*(C'\fR column will be processed automatically for
\&\fBall\fR tables, not just the \f(CW\*(C`user\*(C'\fR table.
.PP
\fIInflate/deflate Processing\fR
.IX Subsection "Inflate/deflate Processing"
.PP
To enable inflate/deflate processing on the columns 
\&\f(CW\*(C`created_at\*(C'\fR and \f(CW\*(C`updated_at\*(C'\fR you can do the following:
.PP
.Vb 6
\&    package Proj::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    use DateTime;
\&    use DateTime::Format::Strptime;
\&    use DateTime::Format::MySQL;
\&    use DateTime::TimeZone;
\&    
\&    my $timezone = DateTime::TimeZone\->new(name => \*(AqAsia/Tokyo\*(Aq);
\&    install_inflate_rule \*(Aq^.+_at$\*(Aq => callback {
\&        inflate {
\&            my $value = shift;
\&            my $dt = DateTime::Format::Strptime\->new(
\&                pattern   => \*(Aq%Y\-%m\-%d %H:%M:%S\*(Aq,
\&                time_zone => $timezone,
\&            )\->parse_datetime($value);
\&            return DateTime\->from_object( object => $dt );
\&        };
\&        deflate {
\&            my $value = shift;
\&            return DateTime::Format::MySQL\->format_datetime($value);
\&        };
\&    };
\&    
\&    install_table \*(Aquser\*(Aq => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id guid login_id login_pw name mail created_at updated_at
\&        /;
\&    };
\&    1;
.Ve
.PP
\fITriggers\fR
.IX Subsection "Triggers"
.PP
Skinny supports insert/update/delete triggers:
.PP
.Vb 3
\&    package Proj::Model::Schema;
\&    use DBIx::Skinny::Schema;
\&    use DateTime;
\&    
\&    install_table \*(Aquser\*(Aq => schema {
\&        pk \*(Aqid\*(Aq;
\&        columns qw/
\&            id guid login_id login_pw name mail created_at updated_at
\&        /;
\&        trigger pre_insert => sub {
\&            my ( $class, $args ) = @_;
\&            $args\->{created_at} ||= DateTime\->now;
\&        };
\&    };
\&    1;
.Ve
.PP
The available triggers are:
.PP
\&\f(CW\*(C`pre_insert\*(C'\fR, \f(CW\*(C`post_insert\*(C'\fR, \f(CW\*(C`pre_update\*(C'\fR, \f(CW\*(C`post_update\*(C'\fR, \f(CW\*(C`pre_delete\*(C'\fR,
\&\f(CW\*(C`post_delete\*(C'\fR
.PP
Triggers are stackable, meaning you can have several triggers of the same
type and they will fire in the order of definition.
.SS "new"
.IX Subsection "new"
.Vb 2
\&    my $model = Proj::Model\->new;
\&    $model\->do();
\&
\&
\&
\&    Proj::Model\->do()
.Ve
.SS "connection_info / connect /reconnect / set_dbh"
.IX Subsection "connection_info / connect /reconnect / set_dbh"
\fIconnection_info\fR
.IX Subsection "connection_info"
.PP
\&\f(CW\*(C`connect_info\*(C'\fR is used to set the database connection info:
.PP
.Vb 10
\&    Proj::Model\->connection_info({
\&        dsn      => \*(Aqdbi:mysql:test\*(Aq,
\&        username => \*(Aqusername\*(Aq,
\&        password => \*(Aqpassword\*(Aq
\&        connect_options => +{
\&            RaiseError => 1,
\&            PrintError => 0,
\&            AutoCommit => 1,
\&        },
\&    });
.Ve
.PP
The default \f(CW\*(C`connect_options\*(C'\fR are:
.PP
\&\f(CW\*(C`RaiseError: 1\*(C'\fR
.PP
\&\f(CW\*(C`PrintError: 0\*(C'\fR
.PP
\&\f(CW\*(C`AutoCommit: 1\*(C'\fR
.PP
\fIconnect\fR
.IX Subsection "connect"
.PP
If you want to explictly connect to the database then:
.PP
.Vb 10
\&    Proj::Model\->connect({
\&        dsn      => \*(Aqdbi:mysql:test\*(Aq,
\&        username => \*(Aqusername\*(Aq,
\&        password => \*(Aqpassword\*(Aq
\&        connect_options => +{
\&            RaiseError => 1,
\&            PrintError => 0,
\&            AutoCommit => 1,
\&        },
\&    });
.Ve
.PP
\fIreconnect\fR
.IX Subsection "reconnect"
.PP
.Vb 10
\&    Proj::Model\->reconnect({
\&        dsn      => \*(Aqdbi:mysql:test\*(Aq,
\&        username => \*(Aqusername\*(Aq,
\&        password => \*(Aqpassword\*(Aq
\&        connect_options => +{
\&            RaiseError => 1,
\&            PrintError => 0,
\&            AutoCommit => 1,
\&        },
\&    });
.Ve
.PP
\fIset_dbh\fR
.IX Subsection "set_dbh"
.PP
.Vb 1
\&    Proj::Model\->set_dbh($dbh);
.Ve
.SS "dbh"
.IX Subsection "dbh"
.Vb 1
\&    my $dbh = Proj::Model\->dbh;
.Ve
.SS "do"
.IX Subsection "do"
\&\f(CW\*(C`Model\->do\*(C'\fR is a shortcut for \f(CW\*(C`$dbh\->do\*(C'\fR
.PP
.Vb 6
\&    Proj::Model\->do(q{
\&        CREATE TABLE foo (
\&            id   INT,
\&            name TEXT
\&        )
\&    });
.Ve
.SS "insert / create"
.IX Subsection "insert / create"
To insert records into a table:
.PP
.Vb 4
\&    my $row = Proj::Model\->insert(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
.Ve
.PP
\&\f(CW\*(C`\->insert()\*(C'\fR returns a DBIx::Skinny::Row> class, so you can access
columns like so:
.PP
.Vb 2
\&    print $row\->name; # nekokak
\&    print $row\->mail; # nekokak _at_ gmail.com
\&
\&    my $row = Proj::Model\->create(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
.Ve
.ie n .SS "update ( $table, $values_href, $where )"
.el .SS "update ( \f(CW$table\fP, \f(CW$values_href\fP, \f(CW$where\fP )"
.IX Subsection "update ( $table, $values_href, $where )"
.Vb 1
\&    Proj::Model\->update(\*(Aquser\*(Aq, {name => \*(Aqyappo\*(Aq}, {id => 1})
.Ve
.PP
You can also call the \f(CW\*(C`\->update\*(C'\fR method on the Row object returned
from insert:
.PP
.Vb 5
\&    my $row = Proj::Model\->insert(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
\&    $row\->update({name => \*(Aqyappo\*(Aq});
.Ve
.ie n .SS "delete ( $table, $where )"
.el .SS "delete ( \f(CW$table\fP, \f(CW$where\fP )"
.IX Subsection "delete ( $table, $where )"
.Vb 1
\&    Proj::Model\->delete(\*(Aquser\*(Aq, {id => 1});
\&
\&    my $row = Proj::Model\->insert(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
\&    $row\->delete;
.Ve
.SS "bulk_insert"
.IX Subsection "bulk_insert"
To insert multiple rows at once:
.PP
.Vb 12
\&    Proj::Model\->bulk_insert(\*(Aquser\*(Aq,
\&        [
\&            {
\&                name => \*(Aqnekokak\*(Aq,
\&                mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&            },
\&            {
\&                name => \*(Aqyappo\*(Aq,
\&                mail => \*(Aqyappo _at_ example.com\*(Aq,
\&            },
\&        ]
\&    );
.Ve
.PP
\&\s-1NOTE:\s0 triggers are not supported with bulk inserts
.SS "find_or_create / find_or_insert"
.IX Subsection "find_or_create / find_or_insert"
.Vb 4
\&    my $row = Proj::Model\->find_or_create(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
\&
\&
\&    my $row = Proj::Model\->find_or_insert(\*(Aquser\*(Aq,{
\&        name => \*(Aqnekokak\*(Aq,
\&        mail => \*(Aqnekokak _at_ gmail.com\*(Aq,
\&    });
.Ve
.SS "single / search / search_named /search_by_sql / count"
.IX Subsection "single / search / search_named /search_by_sql / count"
\fIsingle\fR
.IX Subsection "single"
.PP
Used when you want a single row:
.PP
.Vb 1
\&    my $row = Proj::Model\->single(\*(Aquser\*(Aq,{name => \*(Aqnekokak\*(Aq});
.Ve
.PP
\fIsearch ( \f(CI$table\fI, \f(CI$where\fI, \f(CI$limit_offset\fI )\fR
.IX Subsection "search ( $table, $where, $limit_offset )"
.PP
.Vb 6
\&    my $itr = Proj::Model\->search(\*(Aquser\*(Aq,
\&        {
\&            name => \*(Aqnekokak\*(Aq,
\&        },
\&        { }
\&    );
.Ve
.PP
See DBIx::Class::Manual::EN::Resultset for more information on 
the \f(CW$where\fR clause.
.PP
\fIsearch_named ( \f(CI$sql\fI, \f(CI$placeholder_bindings\fI, \f(CI$sprintf_bindings\fI )\fR
.IX Subsection "search_named ( $sql, $placeholder_bindings, $sprintf_bindings )"
.PP
This method supports search with named placeholders:
.PP
.Vb 1
\&    my $itr = Proj::Model\->search_named(q{SELECT * FROM user WHERE id > :id}, {id => 1});
.Ve
.PP
It is also possible to interpolate data with sprintf control strings:
.PP
.Vb 1
\&    my $itr = Proj::Model\->search_named(q{SELECT * FROM user WHERE id > :id LIMIT %s}, {id => 1}, [10]);
.Ve
.PP
A fourth argument can be used to specify a table for query options. (???)
.PP
.Vb 1
\&    my $itr = Proj::Model\->search_named(q{SELECT * FROM user WHERE id > :id LIMIT %s}, {id => 1}, [10], \*(Aquser\*(Aq);
.Ve
.PP
\fIsearch_by_sql\fR
.IX Subsection "search_by_sql"
.PP
Typical DBI-style placeholders:
.PP
.Vb 1
\&    my $itr = Proj::Model\->search_by_sql(q{SELECT * FROM user WHERE id = ?}, [1], \*(Aquser\*(Aq);
.Ve
.PP
\fIcount ( \f(CI$table\fI, \f(CI$count_column\fI, \f(CI$where\fI )\fR
.IX Subsection "count ( $table, $count_column, $where )"
.PP
.Vb 1
\&    my $count = Porj::Model\->count(\*(Aquser\*(Aq , \*(Aqid\*(Aq, {name => \*(Aqnekokak\*(Aq});
.Ve
.SS "resultset"
.IX Subsection "resultset"
Please see DBIx::Skinny::Manual::EN::Resultset
.SS "Transactions"
.IX Subsection "Transactions"
Transactions are easy in Skinny:
.PP
.Vb 1
\&    my $txn = Proj::Model\->txn_scope;
\&    
\&    my $row = Proj::Model\->single(\*(Aquser\*(Aq, {id => 1});
\&    $row\->set({name => \*(Aqnekokak\*(Aq});
\&    $row\->update;
\&    
\&    $txn\->commit;
.Ve
.PP
Here's another way:
.PP
.Vb 1
\&    Proj::Model\->txn_begin;
\&    
\&    my $row = Proj::Model\->single(\*(Aquser\*(Aq, {id => 1});
\&    $row\->set({name => \*(Aqnekokak\*(Aq});
\&    $row\->update;
\&    
\&    Proj::Model\->txn_commit;
\&    Proj::Model\->txn_end;
.Ve
.PP
It is expected that the database support transactions. For MySQL this means
using the InnoDB engine.
.SS "Mixing in methods"
.IX Subsection "Mixing in methods"
\fIClass level\fR
.IX Subsection "Class level"
.PP
.Vb 4
\&    package Proj::Model;
\&    use DBIx::Skinny;
\&    use DBIx::Skinny::Mixin modules => [\*(Aq+Mixin::Foo\*(Aq];
\&    1;
\&
\&    package Mixin::Foo;
\&    sub register_method {
\&        +{
\&            foo => sub { \*(Aqfoo\*(Aq },
\&        };
\&    }
.Ve
.PP
Now
.PP
.Vb 1
\&    Proj::Model\->foo;
.Ve
.PP
is possible
.PP
\fIRow object level\fR
.IX Subsection "Row object level"
.PP
.Vb 9
\&    package Proj::Model::Row::User;
\&    use strict;
\&    use warnings;
\&    use utf8;
\&    use base \*(AqDBIx::Skinny::Row\*(Aq;
\&    sub foo {
\&        say \*(Aqfoo\*(Aq;
\&    }
\&    1;
.Ve
.PP
Now
.PP
.Vb 1
\&    $row\->foo;
.Ve
.PP
is possible.
.PP
Here's a more practical example:
.PP
.Vb 6
\&    package Proj::Model::Row::User;
\&    use base \*(AqDBIx::Skinny::Row\*(Aq;
\&    sub blogs {
\&        my $self = shift;
\&        $self\->{skinny}\->search(\*(Aqblog\*(Aq,{user_id => $self\->id});
\&    }
.Ve
.PP
Now you can call:
.PP
.Vb 1
\&    $user\->blogs;
.Ve
